{"version":3,"sources":["webpack://image-stylization-threading/./src/ts/helpers.ts","webpack://image-stylization-threading/./src/ts/main.ts","webpack://image-stylization-threading/./src/ts/parameters.ts","webpack://image-stylization-threading/./src/ts/plotter/compositing.ts","webpack://image-stylization-threading/./src/ts/plotter/plotter-base.ts","webpack://image-stylization-threading/./src/ts/plotter/plotter-canvas-2d.ts","webpack://image-stylization-threading/./src/ts/plotter/plotter-svg.ts","webpack://image-stylization-threading/./src/ts/plotter/xml-writer.ts","webpack://image-stylization-threading/./src/ts/threading/thread-computer.ts","webpack://image-stylization-threading/./src/ts/threading/thread-plotter.ts","webpack://image-stylization-threading/./src/ts/threading/thread/thread-base.ts","webpack://image-stylization-threading/./src/ts/threading/thread/thread-monochrome.ts","webpack://image-stylization-threading/./src/ts/threading/thread/thread-red-green-blue.ts","webpack://image-stylization-threading/./src/ts/threading/transformation.ts","webpack://image-stylization-threading/webpack/bootstrap","webpack://image-stylization-threading/webpack/startup"],"names":["downloadTextFile","content","filename","fileType","blob","Blob","type","window","navigator","msSaveBlob","URL","createObjectURL","linkElement","document","createElement","download","href","dataset","downloadurl","style","display","body","appendChild","click","removeChild","setTimeout","revokeObjectURL","getQueryStringValue","name","url","location","queryStringStart","indexOf","queryString","substring","length","split","keyValue","decodeURIComponent","declarePolyfills","Array","prototype","includes","console","log","Object","defineProperty","value","element","this","String","repeat","count","Infinity","RangeError","result","i","Helpers","canvasPlotter","PlotterCanvas2D","threadPlotter","threadComputer","needToReset","mainLoop","reset","Parameters","linesOpacity","linesThickness","computeNextSegments","showIndicators","updateIndicators","Page","Canvas","setIndicatorText","plot","debug","drawDebugView","context","requestAnimationFrame","updateBlur","blur","onNewImage","image","showLoader","ThreadComputer","ThreadPlotter","addRedrawObserver","addResetObserver","addBlurChangeObserver","addFileUploadObserver","defaultImage","Image","addEventListener","src","addDownloadObserver","svgPlotter","PlotterSVG","svgString","export","main","EShape","EMode","controlId","redrawObservers","triggerRedraw","observer","resetObservers","triggerReset","Tabs","addObserver","Range","addLazyObserver","Checkbox","Observers","canvasResize","push","isInDebug","updateIndicatorsVisibility","shouldBeVisible","isChecked","setIndicatorsVisibility","setIndicatorVisibility","callback","FileControl","addUploadObserver","filesList","FileReader","onload","readAsDataURL","getValues","getValue","raw","Math","pow","ECompositingOperation","EColor","supportsAdvancedCompositing","computeRawColor","color","MONOCHROME","r","g","b","RED","GREEN","BLUE","resetCanvasCompositing","globalCompositeOperation","useAdvancedCompositing","applyCanvasCompositing","opacity","operation","rawRGB","targetOperation","LIGHTEN","ceil","strokeStyle","Demopage","setErrorMessage","DARKEN","drawBrokenLine","points","thickness","lines","from","to","drawLines","PlotterBase","canvas","getCanvas","getContext","alpha","cssPixel","devicePixelRatio","resize","actualWidth","floor","clientWidth","actualHeight","clientHeight","width","height","initialize","infos","fillStyle","backgroundColor","lineJoin","fillRect","finalize","filter","lineWidth","line","beginPath","moveTo","x","y","lineTo","stroke","closePath","drawPoints","diameter","point","arc","PI","fill","writer","XMLWriter","hasBlur","addLine","startBlock","endBlock","strokeColor","toFixed","start","Date","now","indentationLevel","join","prefix","MIN_SAFE_NUMBER","TWO_PI","clamp","min","max","mix","a","randomItem","list","random","hiddenCanvasData","sourceImage","hiddenCanvas","hiddenCanvasContext","drawThread","plotter","nbSegmentsToIgnore","transformation","computeTransformation","size","scaling","hiddenCanvasScale","lineThickness","compositing","invertColors","thread","iterateOnThreads","peg","transform","lineOpacity","drawPegs","pointSize","pegs","targetContext","drawImage","maxMillisecondsTaken","performance","targetNbSegments","nbLines","nbSegments","lowerNbSegments","resetHiddenCanvas","lineOpacityInternal","iPeg","drawSegmentOnHiddenCanvas","computeError","lastColor","threadToGrow","getThreadToGrow","enableSamplingFor","computeSegment","linethickness","quality","mode","ThreadMonochrome","ThreadRedBlueGreen","computePegs","updateFunction","toString","error","average","meanSquare","variance","totalNbSegments","initializeHiddenCanvasLineProperties","theoricalThicknes","lastPeg","nextPeg","startingSegment","computeBestStartingSegment","peg1","peg2","HISTORY_SIZE","prevousPegs","slice","computeBestNextPeg","wantedSize","computeBestSize","imageData","getImageData","adjustCanvasData","data","putImageData","uploadCanvasDataToCPU","nbPixels","nbSamples","iP","errorRed","errorGreen","errorBlue","round","distancetoError","targetSize","Transformation","candidates","bestScore","step","iPegId1","iPegId2","arePegsTooClose","candidateScore","computeSegmentPotential","currentPeg","pegsToAvoid","p1","p2","dX","dY","potential","segmentLength","sqrt","iSample","sample","sampleCanvasData","coords","minX","maxX","minY","maxY","topLeft","sampleCanvasPixel","topRight","bottomLeft","bottomRight","fractX","top","bottom","pixelX","pixelY","index","sampleCanvas","sourceImageSize","maxSize","sizingFactor","domainSize","DEFAULT_CANVAS_SIZE_FOR_PEGS","aspectRatio","pegsShape","shape","pegsSpacing","RECTANGLE","nbPegsPerWidth","nbPegsPerHeight","iW","iH","absDeltaAngle","abs","angle","nbPegs","baseDeltaAngle","cos","sin","nbSegmentsDrawn","plotterInfos","displayPegs","lowerNbSegmentsForThread","targetNumber","computeNbSegments","iterateOnThread","fromSegmentNumber","ThreadBase","threadPegs","blackBackground","computeAdjustedValue","rawValue","adjustedValue","threadPegsRed","threadPegsGreen","threadPegsBlue","repartition","computeIdealSegmentsRepartition","red","green","blue","cumulatedRed","cumulatedGreen","cumulatedBlue","totalColor","frequencyRed","frequencyGreen","frequencyBlue","channel","idealRed","idealGreen","idealBlue","gapRed","gapGreen","gapBlue","frameSize","elementSize","scaleToFitWidth","scaleToFitHeight","origin","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","call"],"mappings":"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","file":"main.min.js","sourcesContent":["function downloadTextFile(content: string, filename: string): void {\r\n    const fileType = \"text/plain\";\r\n\r\n    const blob = new Blob([content], { type: fileType });\r\n\r\n    if (typeof window.navigator !== \"undefined\" && typeof window.navigator.msSaveBlob !== \"undefined\") { // for IE\r\n        window.navigator.msSaveBlob(blob, filename);\r\n    } else {\r\n        const objectUrl = URL.createObjectURL(blob);\r\n\r\n        const linkElement = document.createElement('a');\r\n        linkElement.download = filename;\r\n        linkElement.href = objectUrl;\r\n        linkElement.dataset.downloadurl = `${fileType}:${linkElement.download}:${linkElement.href}`;\r\n        linkElement.style.display = \"none\";\r\n        document.body.appendChild(linkElement);\r\n        linkElement.click();\r\n        document.body.removeChild(linkElement);\r\n\r\n        // don't forget to free the objectURL after a few seconds\r\n        setTimeout(() => {\r\n            URL.revokeObjectURL(objectUrl);\r\n        }, 5000);\r\n    }\r\n}\r\n\r\nfunction getQueryStringValue(name: string): string | null {\r\n    const url = window.location.href;\r\n    const queryStringStart = url.indexOf(\"?\");\r\n    if (queryStringStart >= 0) {\r\n        const queryString = url.substring(queryStringStart + 1);\r\n        if (queryString.length > 0) {\r\n            const parameters = queryString.split(\"&\");\r\n            for (const parameter of parameters) {\r\n                const keyValue = parameter.split(\"=\");\r\n                if (keyValue.length === 2) {\r\n                    const decodedKey = decodeURIComponent(keyValue[0]);\r\n                    if (decodedKey === name) {\r\n                        return decodeURIComponent(keyValue[1]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nfunction declareArrayIncludesPolyfill(): void {\r\n    if (typeof Array.prototype.includes !== \"function\") {\r\n        console.log(\"Declaring Array.includes polyfill...\");\r\n        Object.defineProperty(Array.prototype, \"includes\", {\r\n            value<T>(this: T[], element: any): boolean {\r\n                return this.indexOf(element) >= 0;\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nfunction declareStringRepeatPolyfill(): void {\r\n    if (typeof String.prototype.repeat !== \"function\") {\r\n        console.log(\"Declaring String.repeat polyfill...\");\r\n        Object.defineProperty(String.prototype, \"repeat\", {\r\n            value(this: string, count: number): string {\r\n                if (count < 0 || count === Infinity) {\r\n                    throw new RangeError();\r\n                }\r\n\r\n                let result = \"\";\r\n                for (let i = 0; i < count; i++) {\r\n                    result += this;\r\n                }\r\n                return result;\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nfunction declarePolyfills(): void {\r\n    declareArrayIncludesPolyfill();\r\n    declareStringRepeatPolyfill();\r\n}\r\n\r\nexport {\r\n    declarePolyfills,\r\n    downloadTextFile,\r\n    getQueryStringValue,\r\n};\r\n","import * as Helpers from \"./helpers\";\r\n\r\nimport { Parameters } from \"./parameters\";\r\n\r\nimport { PlotterCanvas2D } from \"./plotter/plotter-canvas-2d\";\r\nimport { PlotterSVG } from \"./plotter/plotter-svg\";\r\n\r\nimport { ThreadComputer } from \"./threading/thread-computer\";\r\nimport { ThreadPlotter } from \"./threading/thread-plotter\";\r\n\r\nimport \"./page-interface-generated\";\r\n\r\nfunction main(): void {\r\n    const MAX_COMPUTING_TIME_PER_FRAME = 20; // ms\r\n    const canvasPlotter = new PlotterCanvas2D();\r\n    let threadPlotter: ThreadPlotter = null;\r\n    let threadComputer: ThreadComputer = null;\r\n    let needToReset = true;\r\n\r\n    Parameters.addRedrawObserver(() => { threadPlotter?.reset(); });\r\n    Parameters.addResetObserver(() => { needToReset = true; });\r\n\r\n    function mainLoop(): void {\r\n        if (needToReset) {\r\n            threadComputer.reset(Parameters.linesOpacity, Parameters.linesThickness);\r\n            threadPlotter.reset()\r\n            needToReset = false;\r\n        }\r\n\r\n        const computedSomething = threadComputer.computeNextSegments(MAX_COMPUTING_TIME_PER_FRAME);\r\n\r\n        if (computedSomething && Parameters.showIndicators) {\r\n            threadComputer.updateIndicators(Page.Canvas.setIndicatorText);\r\n        }\r\n\r\n        threadPlotter.plot();\r\n\r\n        if (Parameters.debug) {\r\n            threadComputer.drawDebugView(canvasPlotter.context);\r\n        }\r\n\r\n        requestAnimationFrame(mainLoop);\r\n    }\r\n\r\n    function updateBlur(blur: number): void {\r\n        canvasPlotter.blur = blur;\r\n    }\r\n    Parameters.addBlurChangeObserver(updateBlur);\r\n    updateBlur(Parameters.blur);\r\n\r\n    function onNewImage(image: HTMLImageElement): void {\r\n        Page.Canvas.showLoader(false);\r\n        threadComputer = new ThreadComputer(image);\r\n        threadPlotter = new ThreadPlotter(canvasPlotter, threadComputer);\r\n        needToReset = true;\r\n    }\r\n    Parameters.addFileUploadObserver(onNewImage);\r\n\r\n    Page.Canvas.showLoader(true);\r\n    const defaultImage = new Image();\r\n    defaultImage.addEventListener(\"load\", () => {\r\n        onNewImage(defaultImage);\r\n        requestAnimationFrame(mainLoop);\r\n    });\r\n    defaultImage.src = \"./resources/cat.jpg\";\r\n\r\n    Parameters.addDownloadObserver(() => {\r\n        const svgPlotter = new PlotterSVG();\r\n        const plotter = new ThreadPlotter(svgPlotter, threadComputer);\r\n        plotter.plot();\r\n        const svgString = svgPlotter.export();\r\n        const filename = \"image-as-threading.svg\";\r\n        Helpers.downloadTextFile(svgString, filename);\r\n    });\r\n}\r\n\r\nHelpers.declarePolyfills();\r\nmain();\r\n","import * as Helpers from \"./helpers\";\r\n\r\nimport \"./page-interface-generated\";\r\n\r\nconst controlId = {\r\n    UPLOAD_INPUT_IMAGE: \"input-image-upload-button\",\r\n    SHAPE: \"shape-tabs-id\",\r\n    PEGS_DENSITY: \"pegs-range-id\",\r\n    NB_LINES: \"lines-range-id\",\r\n    QUALITY: \"quality-tabs-id\",\r\n    MODE: \"thread-mode-tabs-id\",\r\n    LINES_OPACITY: \"opacity-range-id\",\r\n    LINES_THICKNESS: \"thickness-range-id\",\r\n    DISPLAY_PEGS: \"display-pegs-checkbox-id\",\r\n    INVERT_COLORS: \"invert-colors-checkbox-id\",\r\n    SHOW_INDICATORS: \"show-indicators-checkbox-id\",\r\n    BLUR: \"blur-range-id\",\r\n    DOWNLOAD: \"result-download-id\",\r\n};\r\n\r\nenum EShape {\r\n    RECTANGLE = \"0\",\r\n    ELLIPSIS = \"1\",\r\n}\r\n\r\nenum EMode {\r\n    MONOCHROME = \"0\",\r\n    COLORS = \"1\",\r\n}\r\n\r\ntype Observer = () => unknown;\r\nconst redrawObservers: Observer[] = [];\r\nfunction triggerRedraw(): void {\r\n    for (const observer of redrawObservers) {\r\n        observer();\r\n    }\r\n}\r\n\r\nconst resetObservers: Observer[] = [];\r\nfunction triggerReset(): void {\r\n    for (const observer of resetObservers) {\r\n        observer();\r\n    }\r\n}\r\n\r\nPage.Tabs.addObserver(controlId.SHAPE, triggerReset);\r\nPage.Range.addLazyObserver(controlId.PEGS_DENSITY, triggerReset);\r\nPage.Tabs.addObserver(controlId.QUALITY, triggerReset);\r\nPage.Tabs.addObserver(controlId.MODE, triggerReset);\r\nPage.Range.addLazyObserver(controlId.LINES_OPACITY, triggerReset);\r\nPage.Range.addLazyObserver(controlId.LINES_THICKNESS, triggerReset);\r\nPage.Checkbox.addObserver(controlId.DISPLAY_PEGS, triggerRedraw);\r\nPage.Checkbox.addObserver(controlId.INVERT_COLORS, triggerReset);\r\nPage.Canvas.Observers.canvasResize.push(triggerRedraw);\r\n\r\nconst isInDebug = Helpers.getQueryStringValue(\"debug\") === \"1\";\r\n\r\nPage.Canvas.setIndicatorVisibility(\"error-average\", isInDebug);\r\nPage.Canvas.setIndicatorVisibility(\"error-mean-square\", isInDebug);\r\nPage.Canvas.setIndicatorVisibility(\"error-variance\", isInDebug);\r\n\r\nfunction updateIndicatorsVisibility(): void {\r\n    const shouldBeVisible = Page.Checkbox.isChecked(controlId.SHOW_INDICATORS);\r\n    Page.Canvas.setIndicatorsVisibility(shouldBeVisible);\r\n}\r\nPage.Checkbox.addObserver(controlId.SHOW_INDICATORS, updateIndicatorsVisibility);\r\nupdateIndicatorsVisibility();\r\n\r\nabstract class Parameters {\r\n    public static addFileUploadObserver(callback: (image: HTMLImageElement) => unknown): void {\r\n        Page.FileControl.addUploadObserver(controlId.UPLOAD_INPUT_IMAGE, (filesList: FileList) => {\r\n            if (filesList.length === 1) {\r\n                Page.Canvas.showLoader(true);\r\n                const reader = new FileReader();\r\n                reader.onload = () => {\r\n                    const image = new Image();\r\n                    image.addEventListener(\"load\", () => {\r\n                        callback(image);\r\n                    })\r\n                    image.src = reader.result as string;\r\n                };\r\n                reader.readAsDataURL(filesList[0]);\r\n            }\r\n        });\r\n    }\r\n\r\n    public static get debug(): boolean {\r\n        return isInDebug;\r\n    }\r\n\r\n    public static get shape(): EShape {\r\n        return Page.Tabs.getValues(controlId.SHAPE)[0] as EShape;\r\n    }\r\n\r\n    public static get pegsSpacing(): number {\r\n        return 1.1 - Page.Range.getValue(controlId.PEGS_DENSITY);\r\n    }\r\n\r\n    public static get quality(): number {\r\n        return +Page.Tabs.getValues(controlId.QUALITY)[0];\r\n    }\r\n\r\n    public static get mode(): EMode {\r\n        return Page.Tabs.getValues(controlId.MODE)[0] as EMode;\r\n    }\r\n\r\n    public static get nbLines(): number {\r\n        return Page.Range.getValue(controlId.NB_LINES);\r\n    }\r\n\r\n    public static get linesOpacity(): number {\r\n        const raw = Page.Range.getValue(controlId.LINES_OPACITY);\r\n        return Math.pow(2, raw - 7); // 2^(raw+2) / 256\r\n    }\r\n\r\n    public static get linesThickness(): number {\r\n        return Page.Range.getValue(controlId.LINES_THICKNESS);\r\n    }\r\n\r\n    public static get displayPegs(): boolean {\r\n        return Page.Checkbox.isChecked(controlId.DISPLAY_PEGS);\r\n    }\r\n\r\n    public static get invertColors(): boolean {\r\n        return Page.Checkbox.isChecked(controlId.INVERT_COLORS);\r\n    }\r\n\r\n    public static get showIndicators(): boolean {\r\n        return Page.Checkbox.isChecked(controlId.SHOW_INDICATORS);\r\n    }\r\n\r\n    public static addRedrawObserver(callback: Observer): void {\r\n        redrawObservers.push(callback);\r\n    }\r\n\r\n    public static addResetObserver(callback: Observer): void {\r\n        resetObservers.push(callback);\r\n    }\r\n\r\n    public static get blur(): number {\r\n        return Page.Range.getValue(controlId.BLUR);\r\n    }\r\n    public static addBlurChangeObserver(callback: (newBlur: number) => unknown): void {\r\n        Page.Range.addObserver(controlId.BLUR, callback);\r\n    }\r\n\r\n    public static addDownloadObserver(callback: () => unknown): void {\r\n        Page.FileControl.addDownloadObserver(controlId.DOWNLOAD, callback);\r\n    }\r\n}\r\n\r\nexport {\r\n    Parameters,\r\n    EMode,\r\n    EShape,\r\n};\r\n","import \"../page-interface-generated\";\r\n\r\nenum ECompositingOperation {\r\n    DARKEN,\r\n    LIGHTEN,\r\n}\r\n\r\nenum EColor {\r\n    MONOCHROME,\r\n    RED,\r\n    GREEN,\r\n    BLUE,\r\n}\r\n\r\ninterface IColor {\r\n    r: number;\r\n    g: number;\r\n    b: number;\r\n}\r\n\r\nlet supportsAdvancedCompositing = true;\r\nfunction useAdvancedCompositing(): boolean {\r\n    return supportsAdvancedCompositing;\r\n}\r\n\r\nfunction computeRawColor(color: EColor): IColor {\r\n    if (color === EColor.MONOCHROME) {\r\n        return { r: 1, g: 1, b: 1 };\r\n    }\r\n\r\n    const result: IColor = {\r\n        r: (color === EColor.RED) ? 1 : 0,\r\n        g: (color === EColor.GREEN) ? 1 : 0,\r\n        b: (color === EColor.BLUE) ? 1 : 0,\r\n    };\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * @param opacity in [0, 1]\r\n */\r\nfunction applyCanvasCompositing(context: CanvasRenderingContext2D, color: EColor, opacity: number, operation: ECompositingOperation): void {\r\n    const rawRGB = computeRawColor(color);\r\n\r\n    if (supportsAdvancedCompositing) {\r\n        const targetOperation = (operation === ECompositingOperation.LIGHTEN) ? \"lighter\" : \"difference\";\r\n        context.globalCompositeOperation = targetOperation;\r\n        if (context.globalCompositeOperation === targetOperation) {\r\n            const value = Math.ceil(255 * opacity);\r\n            context.strokeStyle = `rgb(${rawRGB.r * value}, ${rawRGB.g * value}, ${rawRGB.b * value})`;\r\n            return; // success\r\n        } else {\r\n            supportsAdvancedCompositing = false;\r\n            Page.Demopage.setErrorMessage(\"advanced-compositing-not-supported\", `Your browser does not support canvas2D compositing '${targetOperation}'. The project will not run as expected.`);\r\n        }\r\n    }\r\n\r\n    // basic compositing\r\n    {\r\n        resetCanvasCompositing(context);\r\n        if (operation === ECompositingOperation.DARKEN) {\r\n            rawRGB.r = 1 - rawRGB.r;\r\n            rawRGB.g = 1 - rawRGB.g;\r\n            rawRGB.b = 1 - rawRGB.b;\r\n        }\r\n        context.strokeStyle = `rgba(${rawRGB.r * 255}, ${rawRGB.g * 255}, ${rawRGB.b * 255}, ${opacity})`;\r\n    }\r\n}\r\n\r\nfunction resetCanvasCompositing(context: CanvasRenderingContext2D): void {\r\n    context.globalCompositeOperation = \"source-over\";\r\n}\r\n\r\nexport {\r\n    EColor,\r\n    ECompositingOperation,\r\n    applyCanvasCompositing,\r\n    computeRawColor,\r\n    resetCanvasCompositing,\r\n    useAdvancedCompositing,\r\n};\r\n","import { ILine } from \"../interfaces/i-line\";\r\nimport { IPoint } from \"../interfaces/i-point\";\r\nimport { ISize } from \"../interfaces/i-size\";\r\nimport { EColor, ECompositingOperation } from \"./compositing\";\r\n\r\ninterface IPlotterInfo {\r\n    backgroundColor: string;\r\n    blur: number;\r\n}\r\n\r\ninterface IImageFitting {\r\n    sizeInPlotter: ISize;\r\n    imageRelativeToCanvasPixel: (relativeCoords: IPoint) => IPoint;\r\n};\r\n\r\nabstract class PlotterBase {\r\n    public abstract resize(): void;\r\n    public abstract initialize(infos: IPlotterInfo): void;\r\n    public abstract finalize(): void;\r\n\r\n    public abstract drawLines(lines: ILine[], color: EColor, opacity: number, operation: ECompositingOperation, thickness: number): void;\r\n    public abstract drawPoints(points: IPoint[], color: string, diameter: number): void;\r\n\r\n    public abstract get size(): ISize;\r\n\r\n    public drawBrokenLine(points: IPoint[], color: EColor, opacity: number, operation: ECompositingOperation, thickness: number): void {\r\n        const lines: ILine[] = [];\r\n\r\n        for (let i = 0; i < points.length - 1; i++) {\r\n            lines.push({ from: points[i], to: points[i + 1] });\r\n        }\r\n        this.drawLines(lines, color, opacity, operation, thickness);\r\n    }\r\n}\r\n\r\nexport { PlotterBase, IImageFitting, IPlotterInfo, ISize }\r\n","import { ILine } from \"../interfaces/i-line\";\r\nimport { IPoint } from \"../interfaces/i-point\";\r\nimport { ISize } from \"../interfaces/i-size\";\r\nimport { applyCanvasCompositing, EColor, ECompositingOperation, resetCanvasCompositing } from \"./compositing\";\r\nimport { IPlotterInfo, PlotterBase } from \"./plotter-base\";\r\n\r\nimport \"../page-interface-generated\";\r\n\r\nclass PlotterCanvas2D extends PlotterBase {\r\n    private readonly canvas: HTMLCanvasElement;\r\n    public readonly context: CanvasRenderingContext2D;\r\n    private readonly cssPixel: number;\r\n\r\n    public constructor() {\r\n        super();\r\n\r\n        this.canvas = Page.Canvas.getCanvas();\r\n        this.context = this.canvas.getContext(\"2d\", { alpha: false });\r\n        this.cssPixel = window.devicePixelRatio ?? 1;\r\n    }\r\n\r\n    public resize(): void {\r\n        const actualWidth = Math.floor(this.cssPixel * this.canvas.clientWidth);\r\n        const actualHeight = Math.floor(this.cssPixel * this.canvas.clientHeight);\r\n\r\n        if (this.canvas.width !== actualWidth || this.canvas.height !== actualHeight) {\r\n            this.canvas.width = actualWidth;\r\n            this.canvas.height = actualHeight;\r\n        }\r\n    }\r\n\r\n    public initialize(infos: IPlotterInfo): void {\r\n        this.context.fillStyle = infos.backgroundColor;\r\n        this.context.lineJoin = \"round\";\r\n        resetCanvasCompositing(this.context);\r\n        this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n\r\n    // tslint:disable-next-line:no-empty\r\n    public finalize(): void { }\r\n\r\n    public set blur(value: number) {\r\n        if (value === 0) {\r\n            this.canvas.style.filter = \"\";\r\n        } else {\r\n            this.canvas.style.filter = `blur(${value}px)`; // simple blur supported everywhere but with artifacts on the edges\r\n            // artifact-free blur, but not supported everywhere\r\n            this.canvas.style.filter = `url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='a' x='0' y='0' width='1' height='1'%3E%3CfeGaussianBlur stdDeviation='${value}' result='b'/%3E%3CfeMorphology operator='dilate' radius='${value}'/%3E %3CfeMerge%3E%3CfeMergeNode/%3E%3CfeMergeNode in='b'/%3E%3C/feMerge%3E%3C/filter%3E%3C/svg%3E#a\")`;\r\n        }\r\n    }\r\n\r\n    public drawLines(lines: ILine[], color: EColor, opacity: number, operation: ECompositingOperation, thickness: number): void {\r\n        if (lines.length >= 1) {\r\n            applyCanvasCompositing(this.context, color, opacity, operation);\r\n\r\n            this.context.lineWidth = thickness * this.cssPixel;\r\n\r\n            for (const line of lines) {\r\n                this.context.beginPath();\r\n                this.context.moveTo(line.from.x * this.cssPixel, line.from.y * this.cssPixel);\r\n                this.context.lineTo(line.to.x * this.cssPixel, line.to.y * this.cssPixel);\r\n                this.context.stroke();\r\n                this.context.closePath();\r\n            }\r\n\r\n            resetCanvasCompositing(this.context);\r\n        }\r\n    }\r\n\r\n    public drawPoints(points: IPoint[], color: string, diameter: number): void {\r\n        if (points.length > 0) {\r\n            this.context.fillStyle = color;\r\n            this.context.strokeStyle = \"none\";\r\n\r\n            for (const point of points) {\r\n                this.context.beginPath();\r\n                this.context.arc(point.x * this.cssPixel, point.y * this.cssPixel, 0.5 * diameter * this.cssPixel, 0, 2 * Math.PI);\r\n                this.context.fill();\r\n                this.context.closePath();\r\n            }\r\n        }\r\n    }\r\n\r\n    public get size(): ISize {\r\n        return {\r\n            width: Math.floor(this.canvas.width / this.cssPixel),\r\n            height: Math.floor(this.canvas.height / this.cssPixel),\r\n        };\r\n    }\r\n}\r\n\r\nexport { PlotterCanvas2D };\r\n\r\n","import { ILine } from \"../interfaces/i-line\";\r\nimport { IPoint } from \"../interfaces/i-point\";\r\nimport { computeRawColor, EColor, ECompositingOperation, useAdvancedCompositing } from \"./compositing\";\r\nimport { PlotterBase, IPlotterInfo, ISize } from \"./plotter-base\";\r\nimport { XMLWriter } from \"./xml-writer\";\r\n\r\nconst WIDTH = 1000;\r\nconst HEIGHT = 1000;\r\n\r\nconst BLUR_EFFECT_ID = \"gaussianBlur\";\r\n\r\nclass PlotterSVG extends PlotterBase {\r\n    private hasBlur: boolean;\r\n    private writer: XMLWriter;\r\n\r\n    public constructor() {\r\n        super();\r\n    }\r\n\r\n    // tslint:disable-next-line:no-empty\r\n    public resize(): void {\r\n    }\r\n\r\n    public initialize(infos: IPlotterInfo): void {\r\n        this.writer = new XMLWriter();\r\n\r\n        this.hasBlur = infos.blur > 0;\r\n\r\n        this.writer.addLine(`<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>`);\r\n        this.writer.startBlock(`<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" viewBox=\"0 0 ${WIDTH} ${HEIGHT}\">`);\r\n\r\n        if (this.hasBlur) {\r\n            this.writer.startBlock(`<defs>`);\r\n            this.writer.startBlock(`<filter id=\"${BLUR_EFFECT_ID}\" x=\"0\" y=\"0\">`);\r\n            this.writer.addLine(`<feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"${infos.blur}\"/>`);\r\n            this.writer.endBlock(`</filter>`);\r\n            this.writer.endBlock(`</defs>`);\r\n\r\n            this.writer.startBlock(`<g filter=\"url(#${BLUR_EFFECT_ID})\">`);\r\n\r\n        }\r\n\r\n        const margin = 10;\r\n        this.writer.addLine(`<rect fill=\"white\" stroke=\"none\" x=\"${-margin}\" y=\"${-margin}\" width=\"${WIDTH + 2 * margin}\" height=\"${HEIGHT + 2 * margin}\"/>`);\r\n    }\r\n\r\n    public finalize(): void {\r\n        if (this.hasBlur) {\r\n            this.writer.endBlock(`</g>`);\r\n        }\r\n        this.writer.endBlock(`</svg>`);\r\n    }\r\n\r\n    public drawLines(lines: ILine[], color: EColor, opacity: number, operation: ECompositingOperation, thickness: number): void {\r\n        if (lines.length >= 1) {\r\n\r\n            let strokeColor: string;\r\n            if (useAdvancedCompositing()) {\r\n                this.writer.startBlock(`<defs>`);\r\n                this.writer.startBlock(`<style type=\"text/css\">`);\r\n                this.writer.startBlock(`<![CDATA[`);\r\n                this.writer.addLine(`line { mix-blend-mode: difference; }`);\r\n                if (operation === ECompositingOperation.LIGHTEN) {\r\n                    this.writer.addLine(`svg { filter: invert(1); background: black; }`);\r\n                }\r\n                this.writer.endBlock(`]]>`);\r\n                this.writer.endBlock(`</style>`);\r\n                this.writer.endBlock(`</defs>`);\r\n\r\n                const value = Math.ceil(255 * opacity);\r\n                const rawRGB = computeRawColor(color);\r\n                strokeColor = `rgb(${rawRGB.r * value}, ${rawRGB.g * value}, ${rawRGB.b * value})`;\r\n            } else {\r\n                const value = (useAdvancedCompositing()) ? 255 : 0;\r\n                const rawRGB = computeRawColor(color);\r\n                strokeColor = `rgba(${rawRGB.r * value}, ${rawRGB.g * value}, ${rawRGB.b * value}, ${opacity})`;\r\n            }\r\n\r\n            // lines container\r\n            this.writer.startBlock(`<g stroke=\"${strokeColor}\" stroke-width=\"${thickness}\" stroke-linecap=\"round\" fill=\"none\">`);\r\n            for (const line of lines) {\r\n                this.writer.addLine(`<line x1=\"${line.from.x.toFixed(1)}\" y1=\"${line.from.y.toFixed(1)}\" x2=\"${line.to.x.toFixed(1)}\" y2=\"${line.to.y.toFixed(1)}\"/>`);\r\n            }\r\n            this.writer.endBlock(`</g>`);\r\n        }\r\n    }\r\n\r\n    public drawPoints(points: IPoint[], color: string, diameter: number): void {\r\n        if (points.length > 0) {\r\n            this.writer.startBlock(`<g fill=\"${color}\" stroke=\"none\">`);\r\n            for (const point of points) {\r\n                this.writer.addLine(`<circle cx=\"${point.x.toFixed(1)}\" cy=\"${point.y.toFixed(1)}\" r=\"${0.5 * diameter}\"/>`);\r\n            }\r\n            this.writer.endBlock(`</g>`);\r\n        }\r\n    }\r\n\r\n    public export(): string {\r\n        const start = Date.now();\r\n        const result = this.writer.result;\r\n        console.log(`Concatenation took ${Date.now() - start} ms.`);\r\n        return result;\r\n    }\r\n\r\n    public get size(): ISize {\r\n        return {\r\n            width: WIDTH,\r\n            height: HEIGHT,\r\n        };\r\n    }\r\n}\r\n\r\nexport { PlotterSVG }\r\n","class XMLWriter {\r\n    private indentationLevel: number = 0;\r\n    private lines: string[] = [];\r\n\r\n    public get result(): string {\r\n        return this.lines.join(\"\\n\");\r\n    }\r\n\r\n    public startBlock(line: string): void {\r\n        this.addLine(line);\r\n        this.indentationLevel++;\r\n    }\r\n\r\n    public endBlock(line: string): void {\r\n        this.indentationLevel--;\r\n        this.addLine(line);\r\n    }\r\n\r\n    public addLine(line: string): void {\r\n        this.lines.push(this.prefix + line);\r\n    }\r\n\r\n    private get prefix(): string {\r\n        return \"\\t\".repeat(this.indentationLevel);\r\n    }\r\n}\r\n\r\nexport { XMLWriter };\r\n","import { IPoint } from \"../interfaces/i-point\";\r\nimport { ISize } from \"../interfaces/i-size\";\r\nimport { EMode, EShape, Parameters } from \"../parameters\";\r\nimport { PlotterBase } from \"../plotter/plotter-base\";\r\nimport { Transformation } from \"./transformation\";\r\nimport { applyCanvasCompositing, EColor, ECompositingOperation, resetCanvasCompositing } from \"../plotter/compositing\";\r\n\r\nimport { ThreadMonochrome } from \"./thread/thread-monochrome\";\r\nimport { ThreadRedBlueGreen } from \"./thread/thread-red-green-blue\";\r\nimport { ThreadBase } from \"./thread/thread-base\";\r\n\r\nconst MIN_SAFE_NUMBER = -9007199254740991;\r\nconst TWO_PI = 2 * Math.PI;\r\n\r\nfunction clamp(x: number, min: number, max: number): number {\r\n    if (x < min) {\r\n        return min;\r\n    } else if (x > max) {\r\n        return max;\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction mix(a: number, b: number, x: number): number {\r\n    return a * (1 - x) + b * x;\r\n}\r\n\r\nfunction distance(p1: IPoint, p2: IPoint): number {\r\n    const dX = p1.x - p2.x;\r\n    const dY = p1.y - p2.y;\r\n    return Math.sqrt(dX * dX + dY * dY);\r\n}\r\n\r\nfunction randomItem<T>(list: T[]): T {\r\n    if (list.length === 0) {\r\n        return null;\r\n    }\r\n    const randomIndex = Math.floor(Math.random() * list.length);\r\n    return list[randomIndex];\r\n}\r\n\r\ninterface IPeg {\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\ninterface ISegment {\r\n    peg1: IPeg;\r\n    peg2: IPeg;\r\n}\r\n\r\ninterface IErrorMeasure {\r\n    average: number;\r\n    variance: number;\r\n    meanSquare: number;\r\n}\r\n\r\ntype IndicatorUpdateFunction = (indicatorId: string, indicatorValue: string) => unknown;\r\n\r\n/**\r\n * Class used to compute which thread path is the best choice.\r\n */\r\nclass ThreadComputer {\r\n    private readonly sourceImage: HTMLImageElement;\r\n    private readonly hiddenCanvas: HTMLCanvasElement;\r\n    private readonly hiddenCanvasContext: CanvasRenderingContext2D;\r\n    private hiddenCanvasData: ImageData = null\r\n    private hiddenCanvasScale: number;\r\n\r\n    private error: IErrorMeasure;\r\n\r\n    private pegs: IPeg[];\r\n\r\n    private lineOpacity: number; // in the final result\r\n    private lineOpacityInternal: number;\r\n    private lineThickness: number; // abstract unit\r\n\r\n    private thread: ThreadBase;\r\n\r\n    private arePegsTooClose: (peg1: IPeg, peg2: IPeg) => boolean;\r\n\r\n    public constructor(image: HTMLImageElement) {\r\n        this.sourceImage = image;\r\n\r\n        this.hiddenCanvas = document.createElement(\"canvas\");\r\n        this.hiddenCanvasContext = this.hiddenCanvas.getContext(\"2d\");\r\n\r\n        this.reset(16 / 256, 1);\r\n    }\r\n\r\n    public drawThread(plotter: PlotterBase, nbSegmentsToIgnore: number): void {\r\n        const transformation = this.computeTransformation(plotter.size);\r\n        const lineWidth = (transformation.scaling * this.hiddenCanvasScale) * this.lineThickness;\r\n        const compositing = Parameters.invertColors ? ECompositingOperation.LIGHTEN : ECompositingOperation.DARKEN;\r\n\r\n        this.thread.iterateOnThreads(nbSegmentsToIgnore, (thread: IPeg[], color: EColor) => {\r\n            const points: IPoint[] = [];\r\n            for (const peg of thread) {\r\n                points.push(transformation.transform(peg));\r\n            }\r\n\r\n            plotter.drawBrokenLine(points, color, this.lineOpacity, compositing, lineWidth);\r\n        });\r\n    }\r\n\r\n    public drawPegs(plotter: PlotterBase): void {\r\n        const transformation = this.computeTransformation(plotter.size);\r\n        const pointSize = 0.5 * (transformation.scaling * this.hiddenCanvasScale);\r\n\r\n        const points: IPoint[] = [];\r\n        for (const peg of this.pegs) {\r\n            points.push(transformation.transform(peg));\r\n        }\r\n\r\n        plotter.drawPoints(points, \"red\", pointSize);\r\n    }\r\n\r\n    public drawDebugView(targetContext: CanvasRenderingContext2D): void {\r\n        targetContext.drawImage(this.hiddenCanvas, 0, 0, this.hiddenCanvas.width, this.hiddenCanvas.height);\r\n    }\r\n\r\n    /** Returns true if there is nothing more to compute */\r\n    public computeNextSegments(maxMillisecondsTaken: number): boolean {\r\n        const start = performance.now();\r\n\r\n        const targetNbSegments = Parameters.nbLines;\r\n        if (this.nbSegments === targetNbSegments) {\r\n            // no new segment to compute\r\n            return false;\r\n        } else if (this.nbSegments > targetNbSegments) {\r\n            // we drew too many lines already, removes the excess\r\n            this.thread.lowerNbSegments(targetNbSegments);\r\n\r\n            // redraw the hidden canvas from scratch\r\n            this.resetHiddenCanvas();\r\n            this.thread.iterateOnThreads(0, (thread: IPeg[], color: EColor) => {\r\n                applyCanvasCompositing(this.hiddenCanvasContext, color, this.lineOpacityInternal, ECompositingOperation.LIGHTEN);\r\n\r\n                for (let iPeg = 0; iPeg + 1 < thread.length; iPeg++) {\r\n                    this.drawSegmentOnHiddenCanvas(thread[iPeg], thread[iPeg + 1]);\r\n                }\r\n            });\r\n\r\n            this.computeError();\r\n            return true;\r\n        }\r\n\r\n        let lastColor: EColor = null;\r\n        while (this.nbSegments < targetNbSegments && performance.now() - start < maxMillisecondsTaken) {\r\n            const threadToGrow = this.thread.getThreadToGrow();\r\n\r\n            if (lastColor !== threadToGrow.color) {\r\n                applyCanvasCompositing(this.hiddenCanvasContext, threadToGrow.color, this.lineOpacityInternal, ECompositingOperation.LIGHTEN);\r\n                this.thread.enableSamplingFor(threadToGrow.color);\r\n                lastColor = threadToGrow.color;\r\n            }\r\n            this.computeSegment(threadToGrow.thread);\r\n\r\n            if (this.nbSegments % 100 === 0) {\r\n                this.computeError();\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @param opacity in [0,1]\r\n     * @returns true if at least one parameter changed\r\n     */\r\n    public reset(opacity: number, linethickness: number): void {\r\n        this.lineOpacity = opacity;\r\n        this.lineThickness = linethickness;\r\n\r\n        this.hiddenCanvasScale = Parameters.quality;\r\n\r\n        if (Parameters.mode === EMode.MONOCHROME) {\r\n            this.thread = new ThreadMonochrome();\r\n        } else {\r\n            this.thread = new ThreadRedBlueGreen();\r\n        }\r\n        this.resetHiddenCanvas();\r\n\r\n        this.pegs = this.computePegs();\r\n    }\r\n\r\n    public updateIndicators(updateFunction: IndicatorUpdateFunction): void {\r\n        updateFunction(\"pegs-count\", this.pegs.length.toString());\r\n        updateFunction(\"segments-count\", this.nbSegments.toString());\r\n        updateFunction(\"error-average\", this.error.average.toString());\r\n        updateFunction(\"error-mean-square\", this.error.meanSquare.toString());\r\n        updateFunction(\"error-variance\", this.error.variance.toString());\r\n    }\r\n\r\n    public get nbSegments(): number {\r\n        return this.thread.totalNbSegments;\r\n    }\r\n\r\n    private initializeHiddenCanvasLineProperties(): void {\r\n        const theoricalThicknes = this.lineThickness * this.hiddenCanvasScale;\r\n\r\n        if (theoricalThicknes <= 1) {\r\n            // do not go below a line width of 1 because it creates artifact.\r\n            // instead, lower the lines opacity.\r\n            this.lineOpacityInternal = 0.5 * this.lineOpacity * theoricalThicknes;\r\n            this.hiddenCanvasContext.lineWidth = 1;\r\n        } else {\r\n            this.lineOpacityInternal = 0.5 * this.lineOpacity;\r\n            this.hiddenCanvasContext.lineWidth = theoricalThicknes;\r\n        }\r\n    }\r\n\r\n    private computeSegment(thread: IPeg[]): void {\r\n        let lastPeg: IPeg;\r\n        let nextPeg: IPeg;\r\n\r\n        if (thread.length === 0) {\r\n            const startingSegment = this.computeBestStartingSegment();\r\n            thread.push(startingSegment.peg1);\r\n            lastPeg = startingSegment.peg1;\r\n            nextPeg = startingSegment.peg2;\r\n        } else {\r\n            lastPeg = thread[thread.length - 1];\r\n            const HISTORY_SIZE = Math.min(thread.length, 20);\r\n            const prevousPegs = thread.slice(-HISTORY_SIZE);\r\n            nextPeg = this.computeBestNextPeg(lastPeg, prevousPegs);\r\n        }\r\n\r\n        thread.push(nextPeg);\r\n        this.drawSegmentOnHiddenCanvas(lastPeg, nextPeg);\r\n    }\r\n\r\n    private resetHiddenCanvas(): void {\r\n        const wantedSize = ThreadComputer.computeBestSize(this.sourceImage, 100 * this.hiddenCanvasScale);\r\n        this.hiddenCanvas.width = wantedSize.width;\r\n        this.hiddenCanvas.height = wantedSize.height;\r\n\r\n        resetCanvasCompositing(this.hiddenCanvasContext);\r\n        this.hiddenCanvasContext.drawImage(this.sourceImage, 0, 0, wantedSize.width, wantedSize.height);\r\n\r\n        // change the base level so that pure white becomes medium grey\r\n        const imageData = this.hiddenCanvasContext.getImageData(0, 0, wantedSize.width, wantedSize.height);\r\n        this.thread.adjustCanvasData(imageData.data, Parameters.invertColors);\r\n        this.hiddenCanvasContext.putImageData(imageData, 0, 0);\r\n        this.computeError();\r\n\r\n        this.initializeHiddenCanvasLineProperties();\r\n    }\r\n\r\n    private computeError(): void {\r\n        this.uploadCanvasDataToCPU();\r\n\r\n        this.error = {\r\n            average: 0,\r\n            variance: 0,\r\n            meanSquare: 0,\r\n        };\r\n\r\n        const nbPixels = this.hiddenCanvasData.width * this.hiddenCanvasData.height;\r\n        const nbSamples = 3 * nbPixels;\r\n        for (let iP = 0; iP < nbPixels; iP++) {\r\n            const errorRed = 127 - this.hiddenCanvasData.data[4 * iP + 0];\r\n            const errorGreen = 127 - this.hiddenCanvasData.data[4 * iP + 1];\r\n            const errorBlue = 127 - this.hiddenCanvasData.data[4 * iP + 2];\r\n\r\n            this.error.average += errorRed + errorGreen + errorBlue;\r\n            this.error.meanSquare += (errorRed * errorRed) + (errorGreen * errorGreen) + (errorBlue * errorBlue);\r\n        }\r\n        this.error.average = Math.round(this.error.average / nbSamples);\r\n        this.error.meanSquare = Math.round(this.error.meanSquare / nbSamples);\r\n\r\n        for (let iP = 0; iP < nbPixels; iP++) {\r\n            const errorRed = 127 - this.hiddenCanvasData.data[4 * iP + 0];\r\n            const errorGreen = 127 - this.hiddenCanvasData.data[4 * iP + 1];\r\n            const errorBlue = 127 - this.hiddenCanvasData.data[4 * iP + 2];\r\n            const error = (errorRed + errorGreen + errorBlue) / 3;\r\n            const distancetoError = error - this.error.average;\r\n            this.error.variance += distancetoError * distancetoError;\r\n        }\r\n        this.error.variance = Math.round(this.error.variance / nbSamples);\r\n    }\r\n\r\n    private computeTransformation(targetSize: ISize): Transformation {\r\n        return new Transformation(targetSize, this.hiddenCanvas);\r\n    }\r\n\r\n    private drawSegmentOnHiddenCanvas(peg1: IPeg, peg2: IPeg): void {\r\n        this.hiddenCanvasContext.beginPath();\r\n        this.hiddenCanvasContext.moveTo(peg1.x, peg1.y);\r\n        this.hiddenCanvasContext.lineTo(peg2.x, peg2.y);\r\n        this.hiddenCanvasContext.stroke();\r\n        this.hiddenCanvasContext.closePath();\r\n\r\n        // invalidate CPU data\r\n        this.hiddenCanvasData = null;\r\n    }\r\n\r\n    private computeBestStartingSegment(): ISegment {\r\n        let candidates: ISegment[] = [];\r\n        let bestScore = MIN_SAFE_NUMBER;\r\n\r\n        const step = 1 + Math.floor(this.pegs.length / 100);\r\n        for (let iPegId1 = 0; iPegId1 < this.pegs.length; iPegId1 += step) {\r\n            for (let iPegId2 = iPegId1 + 1; iPegId2 < this.pegs.length; iPegId2 += step) {\r\n                const peg1 = this.pegs[iPegId1];\r\n                const peg2 = this.pegs[iPegId2];\r\n\r\n                if (!this.arePegsTooClose(peg1, peg2)) {\r\n                    const candidateScore = this.computeSegmentPotential(peg1, peg2);\r\n                    if (candidateScore > bestScore) {\r\n                        bestScore = candidateScore;\r\n                        candidates = [{ peg1, peg2, }];\r\n                    } else if (candidateScore === bestScore) {\r\n                        candidates.push({ peg1, peg2, });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return randomItem(candidates);\r\n    }\r\n\r\n    private computeBestNextPeg(currentPeg: IPeg, pegsToAvoid: IPeg[]): IPeg {\r\n        let candidates: IPeg[] = [];\r\n        let bestScore = MIN_SAFE_NUMBER;\r\n\r\n        for (const peg of this.pegs) {\r\n            if (!this.arePegsTooClose(currentPeg, peg) && !pegsToAvoid.includes(peg)) {\r\n                const candidateScore = this.computeSegmentPotential(currentPeg, peg);\r\n                if (candidateScore > bestScore) {\r\n                    bestScore = candidateScore;\r\n                    candidates = [peg];\r\n                } else if (candidateScore === bestScore) {\r\n                    candidates.push(peg);\r\n                }\r\n            }\r\n        }\r\n\r\n        return randomItem(candidates);\r\n    }\r\n\r\n    private uploadCanvasDataToCPU(): void {\r\n        if (this.hiddenCanvasData === null) {\r\n            const width = this.hiddenCanvas.width;\r\n            const height = this.hiddenCanvas.height;\r\n            this.hiddenCanvasData = this.hiddenCanvasContext.getImageData(0, 0, width, height);\r\n        }\r\n    }\r\n\r\n    /* The higher the result, the better a choice the thread is. */\r\n    private computeSegmentPotential(peg1: IPeg, peg2: IPeg): number {\r\n        this.uploadCanvasDataToCPU();\r\n\r\n        let potential = 0;\r\n\r\n        const segmentLength = distance(peg1, peg2);\r\n        const nbSamples = Math.ceil(segmentLength);\r\n        for (let iSample = 0; iSample < nbSamples; iSample++) {\r\n            const r = (iSample + 1) / (nbSamples + 1);\r\n            const sample: IPoint = {\r\n                x: mix(peg1.x, peg2.x, r),\r\n                y: mix(peg1.y, peg2.y, r),\r\n            };\r\n\r\n            const imageValue = this.sampleCanvasData(sample);\r\n            const finalValue = imageValue + (this.lineOpacityInternal * 255);\r\n            const contribution = 127 - finalValue;\r\n            potential += contribution;\r\n        }\r\n\r\n        return potential / nbSamples;\r\n    }\r\n\r\n    /** Linear interpolation. Returns a result in [0, 255] */\r\n    private sampleCanvasData(coords: IPoint): number {\r\n        const width = this.hiddenCanvasData.width;\r\n        const height = this.hiddenCanvasData.height;\r\n\r\n        const minX = clamp(Math.floor(coords.x), 0, width - 1);\r\n        const maxX = clamp(Math.ceil(coords.x), 0, width - 1);\r\n        const minY = clamp(Math.floor(coords.y), 0, height - 1);\r\n        const maxY = clamp(Math.ceil(coords.y), 0, height - 1);\r\n\r\n        const topLeft = this.sampleCanvasPixel(minX, minY);\r\n        const topRight = this.sampleCanvasPixel(maxX, minY);\r\n        const bottomLeft = this.sampleCanvasPixel(minX, maxY);\r\n        const bottomRight = this.sampleCanvasPixel(maxX, maxY);\r\n\r\n        const fractX = coords.x % 1;\r\n        const top = mix(topLeft, topRight, fractX);\r\n        const bottom = mix(bottomLeft, bottomRight, fractX);\r\n\r\n        const fractY = coords.y % 1;\r\n        return mix(top, bottom, fractY);\r\n    }\r\n\r\n    private sampleCanvasPixel(pixelX: number, pixelY: number): number {\r\n        const index = 4 * (pixelX + pixelY * this.hiddenCanvasData.width);\r\n        return this.thread.sampleCanvas(this.hiddenCanvasData.data, index);\r\n    }\r\n\r\n    private static computeBestSize(sourceImageSize: ISize, maxSize: number): ISize {\r\n        const maxSourceSide = Math.max(sourceImageSize.width, sourceImageSize.height);\r\n        const sizingFactor = maxSize / maxSourceSide;\r\n        return {\r\n            width: Math.ceil(sourceImageSize.width * sizingFactor),\r\n            height: Math.ceil(sourceImageSize.height * sizingFactor),\r\n        };\r\n    }\r\n\r\n    private computePegs(): IPeg[] {\r\n        /* First, compute pegs for a fixed-size canvas*/\r\n        let domainSize: ISize;\r\n        {\r\n            const DEFAULT_CANVAS_SIZE_FOR_PEGS = 1000;\r\n            const aspectRatio = this.hiddenCanvas.width / this.hiddenCanvas.height;\r\n            if (aspectRatio > 1) {\r\n                domainSize = { width: DEFAULT_CANVAS_SIZE_FOR_PEGS, height: Math.round(DEFAULT_CANVAS_SIZE_FOR_PEGS / aspectRatio) };\r\n            } else {\r\n                domainSize = { width: Math.round(DEFAULT_CANVAS_SIZE_FOR_PEGS * aspectRatio), height: DEFAULT_CANVAS_SIZE_FOR_PEGS };\r\n            }\r\n        }\r\n        const pegsShape = Parameters.shape;\r\n        const pegsSpacing = 20 * Parameters.pegsSpacing;\r\n\r\n        const pegs: IPeg[] = [];\r\n\r\n        if (pegsShape === EShape.RECTANGLE) {\r\n            this.arePegsTooClose = (peg1: IPeg, peg2: IPeg) => {\r\n                return peg1.x === peg2.x || peg1.y === peg2.y;\r\n            };\r\n\r\n            const maxX = domainSize.width;\r\n            const maxY = domainSize.height;\r\n\r\n            const nbPegsPerWidth = Math.ceil(maxX / pegsSpacing);\r\n            const nbPegsPerHeight = Math.ceil(maxY / pegsSpacing);\r\n\r\n            pegs.push({ x: 0, y: 0 });\r\n\r\n            for (let iW = 1; iW < nbPegsPerWidth; iW++) {\r\n                pegs.push({ x: maxX * (iW / nbPegsPerWidth), y: 0 });\r\n            }\r\n\r\n            pegs.push({ x: maxX, y: 0 });\r\n\r\n            for (let iH = 1; iH < nbPegsPerHeight; iH++) {\r\n                pegs.push({ x: maxX, y: maxY * (iH / nbPegsPerHeight) });\r\n            }\r\n\r\n            pegs.push({ x: maxX, y: maxY });\r\n\r\n            for (let iW = nbPegsPerWidth - 1; iW >= 1; iW--) {\r\n                pegs.push({ x: maxX * (iW / nbPegsPerWidth), y: maxY });\r\n            }\r\n\r\n            pegs.push({ x: 0, y: maxY });\r\n\r\n            for (let iH = nbPegsPerHeight - 1; iH >= 1; iH--) {\r\n                pegs.push({ x: 0, y: maxY * (iH / nbPegsPerHeight) });\r\n            }\r\n        } else {\r\n            interface IPegCircle extends IPeg {\r\n                angle: number;\r\n            }\r\n\r\n            this.arePegsTooClose = (peg1: IPeg, peg2: IPeg) => {\r\n                const absDeltaAngle = Math.abs((peg1 as IPegCircle).angle - (peg2 as IPegCircle).angle);\r\n                const minAngle = Math.min(absDeltaAngle, TWO_PI - absDeltaAngle);\r\n                return minAngle <= TWO_PI / 16;\r\n            };\r\n\r\n            const maxSize = Math.max(domainSize.width, domainSize.height);\r\n            const nbPegs = Math.ceil(0.5 * TWO_PI * maxSize / pegsSpacing);\r\n            const baseDeltaAngle = TWO_PI / nbPegs;\r\n            for (let iPeg = 0; iPeg < nbPegs; iPeg++) {\r\n                const angle = iPeg * baseDeltaAngle;\r\n                const peg: IPegCircle = {\r\n                    x: 0.5 * domainSize.width * (1 + Math.cos(angle)),\r\n                    y: 0.5 * domainSize.height * (1 + Math.sin(angle)),\r\n                    angle,\r\n                }\r\n                pegs.push(peg);\r\n            }\r\n        }\r\n\r\n        /* Then adjust the pegs to the actual canvas size */\r\n        for (const peg of pegs) {\r\n            peg.x *= this.hiddenCanvas.width / domainSize.width;\r\n            peg.y *= this.hiddenCanvas.height / domainSize.height;\r\n        }\r\n\r\n        return pegs;\r\n    }\r\n}\r\n\r\nexport { ThreadComputer, IPeg };\r\n","import { Parameters } from \"../parameters\";\r\nimport { IPlotterInfo, PlotterBase } from \"../plotter/plotter-base\";\r\nimport { ThreadComputer } from \"./thread-computer\";\r\n\r\nclass ThreadPlotter {\r\n    private nbSegmentsDrawn: number = 0;\r\n\r\n    public constructor(private readonly plotter: PlotterBase, private readonly threadComputer: ThreadComputer) { }\r\n\r\n    public reset(): void {\r\n        this.nbSegmentsDrawn = 0;\r\n    }\r\n\r\n    public plot(): void {\r\n        if (this.nbSegmentsDrawn === this.threadComputer.nbSegments) {\r\n            // nothing more to do\r\n            return;\r\n        } else if (this.nbSegmentsDrawn > this.threadComputer.nbSegments) {\r\n            // if the nb of segment went down, no other choice that redrawing all from scratch\r\n            this.nbSegmentsDrawn = 0;\r\n        }\r\n\r\n        const drawFromScratch = (this.nbSegmentsDrawn === 0);\r\n        if (drawFromScratch) {\r\n            const plotterInfos: IPlotterInfo = {\r\n                backgroundColor: Parameters.invertColors ? \"black\" : \"white\",\r\n                blur: Parameters.blur,\r\n            };\r\n\r\n            this.plotter.resize();\r\n            this.plotter.initialize(plotterInfos);\r\n\r\n            if (Parameters.displayPegs) {\r\n                this.threadComputer.drawPegs(this.plotter);\r\n            }\r\n\r\n            this.threadComputer.drawThread(this.plotter, 0);\r\n            this.plotter.finalize();\r\n        } else {\r\n            this.threadComputer.drawThread(this.plotter, this.nbSegmentsDrawn);\r\n        }\r\n\r\n        this.nbSegmentsDrawn = this.threadComputer.nbSegments;\r\n    }\r\n}\r\n\r\nexport { ThreadPlotter };\r\n","import { EColor } from \"../../plotter/compositing\";\r\nimport { IPeg } from \"../thread-computer\";\r\n\r\ntype ThreadsIterator = (thread: IPeg[], color: EColor) => unknown;\r\n\r\ntype SamplingFunction = (data: Uint8ClampedArray, index: number) => number;\r\n\r\ninterface IThreadToGrow {\r\n    thread: IPeg[];\r\n    color: EColor;\r\n}\r\n\r\nabstract class ThreadBase {\r\n    public abstract get totalNbSegments(): number;\r\n\r\n    public abstract lowerNbSegments(targetNumber: number): void;\r\n\r\n    public abstract iterateOnThreads(nbSegmentsToIgnore: number, callback: ThreadsIterator): void;\r\n\r\n    public abstract getThreadToGrow(): IThreadToGrow;\r\n\r\n    public abstract adjustCanvasData(data: Uint8ClampedArray, blackBackground: boolean): void;\r\n\r\n    public abstract enableSamplingFor(color: EColor): void;\r\n\r\n    /**\r\n     * @returns value in [0, 255]. Ideal value is 127\r\n     */\r\n    public sampleCanvas: SamplingFunction = null;\r\n\r\n    protected static lowerNbSegmentsForThread(thread: IPeg[], targetNumber: number): void {\r\n        if (targetNumber > 0) {\r\n            thread.length = Math.min(thread.length, targetNumber + 1);\r\n        } else {\r\n            thread.length = 0;\r\n        }\r\n    }\r\n\r\n    protected static computeNbSegments(thread: IPeg[]): number {\r\n        return (thread.length > 1) ? thread.length - 1 : 0;\r\n    }\r\n\r\n    public static iterateOnThread(thread: IPeg[], color: EColor, fromSegmentNumber: number, callback: ThreadsIterator): void {\r\n        const threadLength = ThreadBase.computeNbSegments(thread);\r\n        if (fromSegmentNumber < threadLength) {\r\n            const threadPart = thread.slice(fromSegmentNumber);\r\n            callback(threadPart, color);\r\n        }\r\n    }\r\n}\r\n\r\nexport {\r\n    IThreadToGrow,\r\n    ThreadBase,\r\n    ThreadsIterator,\r\n};\r\n","import { EColor } from \"../../plotter/compositing\";\r\nimport { IPeg } from \"../thread-computer\";\r\n\r\nimport { IThreadToGrow, ThreadBase, ThreadsIterator } from \"./thread-base\";\r\n\r\nclass ThreadMonochrome extends ThreadBase {\r\n    private threadPegs: IPeg[] = [];\r\n\r\n    public get totalNbSegments(): number {\r\n        return ThreadBase.computeNbSegments(this.threadPegs);\r\n    }\r\n\r\n    public lowerNbSegments(targetNumber: number): void {\r\n        ThreadBase.lowerNbSegmentsForThread(this.threadPegs, targetNumber);\r\n    }\r\n\r\n    public iterateOnThreads(nbSegmentsToIgnore: number, callback: ThreadsIterator): void {\r\n        ThreadBase.iterateOnThread(this.threadPegs, EColor.MONOCHROME, nbSegmentsToIgnore, callback);\r\n    }\r\n\r\n    public getThreadToGrow(): IThreadToGrow {\r\n        return {\r\n            thread: this.threadPegs,\r\n            color: EColor.MONOCHROME,\r\n        }\r\n    }\r\n\r\n    public adjustCanvasData(data: Uint8ClampedArray, blackBackground: boolean): void {\r\n        let computeAdjustedValue: (rawValue: number) => number;\r\n        if (blackBackground) {\r\n            computeAdjustedValue = (rawValue: number) => (255 - rawValue) / 2;\r\n        } else {\r\n            computeAdjustedValue = (rawValue: number) => rawValue / 2;\r\n        }\r\n\r\n        const nbPixels = data.length / 4;\r\n        for (let i = 0; i < nbPixels; i++) {\r\n            const averageSourceValue = (data[4 * i + 0] + data[4 * i + 1] + data[4 * i + 2]) / 3;\r\n            const adjustedValue = computeAdjustedValue(averageSourceValue);\r\n            data[4 * i + 0] = adjustedValue;\r\n            data[4 * i + 1] = adjustedValue;\r\n            data[4 * i + 2] = adjustedValue;\r\n        }\r\n    }\r\n\r\n    public enableSamplingFor(): void {\r\n        if (this.sampleCanvas === null) {\r\n            this.sampleCanvas = (data: Uint8ClampedArray, index: number) => {\r\n                return data[index + 0]; // only check the red channel because the hidden canvas is in black and white\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport { ThreadMonochrome };\r\n","import { EColor } from \"../../plotter/compositing\";\r\nimport { IPeg } from \"../thread-computer\";\r\n\r\nimport { IThreadToGrow, ThreadBase, ThreadsIterator } from \"./thread-base\";\r\n\r\ninterface ISegmentsRepartition {\r\n    red: number;\r\n    green: number;\r\n    blue: number;\r\n}\r\n\r\nclass ThreadRedBlueGreen extends ThreadBase {\r\n    private threadPegsRed: IPeg[] = [];\r\n    private threadPegsGreen: IPeg[] = [];\r\n    private threadPegsBlue: IPeg[] = [];\r\n\r\n    // indicators describing the colors repartition from the source image\r\n    private frequencyRed: number;\r\n    private frequencyGreen: number;\r\n    private frequencyBlue: number;\r\n\r\n    public get totalNbSegments(): number {\r\n        return ThreadBase.computeNbSegments(this.threadPegsRed) +\r\n            ThreadBase.computeNbSegments(this.threadPegsGreen) +\r\n            ThreadBase.computeNbSegments(this.threadPegsBlue);\r\n    }\r\n\r\n    public lowerNbSegments(targetNumber: number): void {\r\n        const repartition = this.computeIdealSegmentsRepartition(targetNumber);\r\n\r\n        ThreadBase.lowerNbSegmentsForThread(this.threadPegsRed, repartition.red);\r\n        ThreadBase.lowerNbSegmentsForThread(this.threadPegsGreen, repartition.green);\r\n        ThreadBase.lowerNbSegmentsForThread(this.threadPegsBlue, repartition.blue);\r\n    }\r\n\r\n    public iterateOnThreads(nbSegmentsToIgnore: number, callback: ThreadsIterator): void {\r\n        const repartition = this.computeIdealSegmentsRepartition(nbSegmentsToIgnore);\r\n\r\n        ThreadBase.iterateOnThread(this.threadPegsRed, EColor.RED, repartition.red, callback);\r\n        ThreadBase.iterateOnThread(this.threadPegsGreen, EColor.GREEN, repartition.green, callback);\r\n        ThreadBase.iterateOnThread(this.threadPegsBlue, EColor.BLUE, repartition.blue, callback);\r\n    }\r\n\r\n    public getThreadToGrow(): IThreadToGrow {\r\n        const repartition = this.computeIdealSegmentsRepartition(this.totalNbSegments + 1);\r\n        if (repartition.red > 0 && this.threadPegsRed.length < repartition.red + 1) {\r\n            return {\r\n                thread: this.threadPegsRed,\r\n                color: EColor.RED,\r\n            };\r\n        } else if (repartition.green > 0 && this.threadPegsGreen.length < repartition.green + 1) {\r\n            return {\r\n                thread: this.threadPegsGreen,\r\n                color: EColor.GREEN,\r\n            };\r\n        }\r\n\r\n        return {\r\n            thread: this.threadPegsBlue,\r\n            color: EColor.BLUE,\r\n        };\r\n    }\r\n\r\n    public adjustCanvasData(data: Uint8ClampedArray, blackBackground: boolean): void {\r\n        let cumulatedRed = 0;\r\n        let cumulatedGreen = 0;\r\n        let cumulatedBlue = 0;\r\n\r\n        let computeAdjustedValue: (rawValue: number) => number;\r\n        if (blackBackground) {\r\n            computeAdjustedValue = (rawValue: number) => (255 - rawValue) / 2;\r\n        } else {\r\n            computeAdjustedValue = (rawValue: number) => rawValue / 2;\r\n        }\r\n\r\n        const nbPixels = data.length / 4;\r\n        for (let i = 0; i < nbPixels; i++) {\r\n            cumulatedRed += data[4 * i + 0];\r\n            cumulatedGreen += data[4 * i + 1];\r\n            cumulatedBlue += data[4 * i + 2];\r\n\r\n            data[4 * i + 0] = computeAdjustedValue(data[4 * i + 0]);\r\n            data[4 * i + 1] = computeAdjustedValue(data[4 * i + 1]);\r\n            data[4 * i + 2] = computeAdjustedValue(data[4 * i + 2]);\r\n        }\r\n\r\n        if (!blackBackground) {\r\n            cumulatedRed = 255 * nbPixels - cumulatedRed;\r\n            cumulatedGreen = 255 * nbPixels - cumulatedGreen;\r\n            cumulatedBlue = 255 * nbPixels - cumulatedBlue;\r\n        }\r\n\r\n        const totalColor = cumulatedRed + cumulatedGreen + cumulatedBlue;\r\n        this.frequencyRed = cumulatedRed / totalColor;\r\n        this.frequencyGreen = cumulatedGreen / totalColor;\r\n        this.frequencyBlue = cumulatedBlue / totalColor;\r\n    }\r\n\r\n    public enableSamplingFor(color: EColor): void {\r\n        let channel: number;\r\n        if (color === EColor.RED) {\r\n            channel = 0;\r\n        } else if (color === EColor.GREEN) {\r\n            channel = 1;\r\n        } else {\r\n            channel = 2;\r\n        }\r\n\r\n        this.sampleCanvas = (data: Uint8ClampedArray, index: number) => {\r\n            return data[index + channel];\r\n        }\r\n    }\r\n\r\n    private computeIdealSegmentsRepartition(totalNbSegments: number): ISegmentsRepartition {\r\n        const idealRed = totalNbSegments * this.frequencyRed;\r\n        const idealGreen = totalNbSegments * this.frequencyGreen;\r\n        const idealBlue = totalNbSegments * this.frequencyBlue;\r\n\r\n        const repartition = {\r\n            red: Math.floor(idealRed),\r\n            green: Math.floor(idealGreen),\r\n            blue: Math.floor(idealBlue),\r\n        };\r\n\r\n        while (repartition.red + repartition.green + repartition.blue < totalNbSegments) {\r\n            const currentFrequencyRed = repartition.red / Math.max(1, repartition.red + repartition.green + repartition.blue);\r\n            const currentFrequencyGreen = repartition.green / Math.max(1, repartition.red + repartition.green + repartition.blue);\r\n            const currentFrequencyBlue = repartition.blue / Math.max(1, repartition.red + repartition.green + repartition.blue);\r\n\r\n            const gapRed = idealRed - currentFrequencyRed;\r\n            const gapGreen = idealGreen - currentFrequencyGreen;\r\n            const gapBlue = idealBlue - currentFrequencyBlue;\r\n\r\n            if (gapRed > gapGreen && gapRed > gapBlue) {\r\n                repartition.red++;\r\n            } else if (gapGreen > gapRed && gapGreen > gapBlue) {\r\n                repartition.green++;\r\n            } else {\r\n                repartition.blue++;\r\n            }\r\n        }\r\n\r\n        return repartition;\r\n    }\r\n}\r\n\r\nexport { ThreadRedBlueGreen };\r\n","import { IPoint } from \"../interfaces/i-point\";\r\nimport { ISize } from \"../interfaces/i-size\";\r\n\r\nclass Transformation {\r\n    public readonly scaling: number;\r\n    public readonly origin: IPoint;\r\n\r\n    public constructor(frameSize: ISize, elementSize: ISize) {\r\n        const scaleToFitWidth = frameSize.width / elementSize.width;\r\n        const scaleToFitHeight = frameSize.height / elementSize.height;\r\n\r\n        this.scaling = Math.min(scaleToFitWidth, scaleToFitHeight);\r\n        this.origin = {\r\n            x: 0.5 * (frameSize.width - this.scaling * elementSize.width),\r\n            y: 0.5 * (frameSize.height - this.scaling * elementSize.height)\r\n        };\r\n    }\r\n\r\n    public transform(point: IPoint): IPoint {\r\n        return {\r\n            x: this.origin.x + point.x * this.scaling,\r\n            y: this.origin.y + point.y * this.scaling,\r\n        };\r\n    }\r\n}\r\n\r\nexport { Transformation };\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(633);\n"],"sourceRoot":""}