{"version":3,"sources":["webpack://image-stylization-threading/./src/ts/helpers.ts","webpack://image-stylization-threading/./src/ts/main.ts","webpack://image-stylization-threading/./src/ts/parameters.ts","webpack://image-stylization-threading/./src/ts/plotter/compositing.ts","webpack://image-stylization-threading/./src/ts/plotter/plotter-base.ts","webpack://image-stylization-threading/./src/ts/plotter/plotter-canvas-2d.ts","webpack://image-stylization-threading/./src/ts/plotter/plotter-svg.ts","webpack://image-stylization-threading/./src/ts/plotter/xml-writer.ts","webpack://image-stylization-threading/./src/ts/threading/thread-computer.ts","webpack://image-stylization-threading/./src/ts/threading/thread-plotter.ts","webpack://image-stylization-threading/./src/ts/threading/thread/thread-base.ts","webpack://image-stylization-threading/./src/ts/threading/thread/thread-monochrome.ts","webpack://image-stylization-threading/./src/ts/threading/thread/thread-red-green-blue.ts","webpack://image-stylization-threading/./src/ts/threading/transformation.ts","webpack://image-stylization-threading/webpack/bootstrap","webpack://image-stylization-threading/webpack/startup"],"names":["downloadTextFile","content","filename","fileType","blob","Blob","type","window","navigator","msSaveBlob","URL","createObjectURL","linkElement","document","createElement","download","href","dataset","downloadurl","style","display","body","appendChild","click","removeChild","setTimeout","revokeObjectURL","getQueryStringValue","name","url","location","queryStringStart","indexOf","queryString","substring","length","split","keyValue","decodeURIComponent","canvasPlotter","PlotterCanvas2D","threadPlotter","threadComputer","needToReset","mainLoop","reset","Parameters","linesOpacity","linesThickness","computeNextSegments","showIndicators","updateIndicators","Page","Canvas","setIndicatorText","plot","debug","drawDebugView","context","requestAnimationFrame","updateBlur","blur","onNewImage","image","showLoader","ThreadComputer","ThreadPlotter","addRedrawObserver","addResetObserver","addBlurChangeObserver","addFileUploadObserver","defaultImage","Image","addEventListener","src","addDownloadObserver","svgPlotter","PlotterSVG","svgString","export","Helpers","main","EShape","EMode","controlId","redrawObservers","triggerRedraw","observer","resetObservers","triggerReset","Tabs","addObserver","Range","addLazyObserver","Checkbox","Observers","canvasResize","push","isInDebug","updateIndicatorsVisibility","shouldBeVisible","isChecked","setIndicatorsVisibility","setIndicatorVisibility","callback","FileControl","addUploadObserver","filesList","FileReader","onload","result","readAsDataURL","getValues","getValue","raw","Math","pow","ECompositingOperation","EColor","supportsAdvancedCompositing","computeRawColor","color","MONOCHROME","r","g","b","RED","GREEN","BLUE","resetCanvasCompositing","globalCompositeOperation","useAdvancedCompositing","applyCanvasCompositing","opacity","operation","targetOperation","LIGHTEN","value","ceil","rawRGB","strokeStyle","Demopage","setErrorMessage","drawBrokenLine","points","thickness","lines","i","from","to","this","drawLines","PlotterBase","canvas","getCanvas","getContext","alpha","cssPixel","devicePixelRatio","resize","actualWidth","floor","clientWidth","actualHeight","clientHeight","width","height","initialize","infos","fillStyle","backgroundColor","lineJoin","fillRect","finalize","filter","lineWidth","line","beginPath","moveTo","x","y","lineTo","stroke","closePath","drawPoints","diameter","point","arc","PI","fill","writer","XMLWriter","hasBlur","addLine","startBlock","endBlock","strokeColor","toFixed","start","Date","now","console","log","indentationLevel","join","prefix","repeat","MIN_SAFE_NUMBER","TWO_PI","clamp","min","max","mix","a","randomItem","list","random","hiddenCanvasData","sourceImage","hiddenCanvas","hiddenCanvasContext","drawThread","plotter","nbSegmentsToIgnore","transformation","computeTransformation","size","scaling","hiddenCanvasScale","lineThickness","compositing","invertColors","DARKEN","thread","iterateOnThreads","peg","transform","lineOpacity","drawPegs","pointSize","pegs","targetContext","drawImage","maxMillisecondsTaken","performance","targetNbSegments","nbLines","nbSegments","lowerNbSegments","resetHiddenCanvas","lineOpacityInternal","iPeg","drawSegmentOnHiddenCanvas","computeError","lastColor","threadToGrow","getThreadToGrow","enableSamplingFor","computeSegment","linethickness","quality","mode","ThreadMonochrome","ThreadRedBlueGreen","computePegs","updateFunction","toString","error","average","meanSquare","variance","totalNbSegments","initializeHiddenCanvasLineProperties","theoricalThicknes","lastPeg","nextPeg","startingSegment","computeBestStartingSegment","peg1","peg2","HISTORY_SIZE","prevousPegs","slice","computeBestNextPeg","wantedSize","computeBestSize","imageData","getImageData","adjustCanvasData","data","putImageData","uploadCanvasDataToCPU","nbPixels","nbSamples","iP","errorRed","errorGreen","errorBlue","round","distancetoError","targetSize","Transformation","candidates","bestScore","step","iPegId1","iPegId2","arePegsTooClose","candidateScore","computeSegmentPotential","currentPeg","pegsToAvoid","includes","p1","p2","dX","dY","potential","segmentLength","sqrt","iSample","sample","sampleCanvasData","coords","minX","maxX","minY","maxY","topLeft","sampleCanvasPixel","topRight","bottomLeft","bottomRight","fractX","top","bottom","pixelX","pixelY","index","sampleCanvas","sourceImageSize","maxSize","sizingFactor","domainSize","DEFAULT_CANVAS_SIZE_FOR_PEGS","aspectRatio","pegsShape","shape","pegsSpacing","RECTANGLE","nbPegsPerWidth","iW","nbPegsPerHeight","iH","absDeltaAngle","abs","angle","nbPegs","baseDeltaAngle","cos","sin","nbSegmentsDrawn","plotterInfos","displayPegs","lowerNbSegmentsForThread","targetNumber","computeNbSegments","iterateOnThread","fromSegmentNumber","ThreadBase","threadPegs","blackBackground","computeAdjustedValue","rawValue","adjustedValue","threadPegsRed","threadPegsGreen","threadPegsBlue","repartition","computeIdealSegmentsRepartition","red","green","blue","cumulatedRed","cumulatedGreen","cumulatedBlue","totalColor","frequencyRed","frequencyGreen","frequencyBlue","channel","idealRed","idealGreen","idealBlue","gapRed","gapGreen","gapBlue","frameSize","elementSize","scaleToFitWidth","scaleToFitHeight","origin","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","call"],"mappings":"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","file":"main.min.js","sourcesContent":["function downloadTextFile(content: string, filename: string): void {\r\n    const fileType = \"text/plain\";\r\n\r\n    const blob = new Blob([content], { type: fileType });\r\n\r\n    if (typeof window.navigator !== \"undefined\" && typeof window.navigator.msSaveBlob !== \"undefined\") { // for IE\r\n        window.navigator.msSaveBlob(blob, filename);\r\n    } else {\r\n        const objectUrl = URL.createObjectURL(blob);\r\n\r\n        const linkElement = document.createElement('a');\r\n        linkElement.download = filename;\r\n        linkElement.href = objectUrl;\r\n        linkElement.dataset.downloadurl = `${fileType}:${linkElement.download}:${linkElement.href}`;\r\n        linkElement.style.display = \"none\";\r\n        document.body.appendChild(linkElement);\r\n        linkElement.click();\r\n        document.body.removeChild(linkElement);\r\n\r\n        // don't forget to free the objectURL after a few seconds\r\n        setTimeout(() => {\r\n            URL.revokeObjectURL(objectUrl);\r\n        }, 5000);\r\n    }\r\n}\r\n\r\nfunction getQueryStringValue(name: string): string | null {\r\n    const url = window.location.href;\r\n    const queryStringStart = url.indexOf(\"?\");\r\n    if (queryStringStart >= 0) {\r\n        const queryString = url.substring(queryStringStart + 1);\r\n        if (queryString.length > 0) {\r\n            const parameters = queryString.split(\"&\");\r\n            for (const parameter of parameters) {\r\n                const keyValue = parameter.split(\"=\");\r\n                if (keyValue.length === 2) {\r\n                    const decodedKey = decodeURIComponent(keyValue[0]);\r\n                    if (decodedKey === name) {\r\n                        return decodeURIComponent(keyValue[1]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nexport {\r\n    downloadTextFile,\r\n    getQueryStringValue,\r\n};\r\n","import * as Helpers from \"./helpers\";\r\n\r\nimport { Parameters } from \"./parameters\";\r\n\r\nimport { PlotterCanvas2D } from \"./plotter/plotter-canvas-2d\";\r\nimport { PlotterSVG } from \"./plotter/plotter-svg\";\r\n\r\nimport { ThreadComputer } from \"./threading/thread-computer\";\r\nimport { ThreadPlotter } from \"./threading/thread-plotter\";\r\n\r\nimport \"./page-interface-generated\";\r\n\r\nfunction main(): void {\r\n    const MAX_COMPUTING_TIME_PER_FRAME = 20; // ms\r\n    const canvasPlotter = new PlotterCanvas2D();\r\n    let threadPlotter: ThreadPlotter = null;\r\n    let threadComputer: ThreadComputer = null;\r\n    let needToReset = true;\r\n\r\n    Parameters.addRedrawObserver(() => { threadPlotter?.reset(); });\r\n    Parameters.addResetObserver(() => { needToReset = true; });\r\n\r\n    function mainLoop(): void {\r\n        if (needToReset) {\r\n            threadComputer.reset(Parameters.linesOpacity, Parameters.linesThickness);\r\n            threadPlotter.reset()\r\n            needToReset = false;\r\n        }\r\n\r\n        const computedSomething = threadComputer.computeNextSegments(MAX_COMPUTING_TIME_PER_FRAME);\r\n\r\n        if (computedSomething && Parameters.showIndicators) {\r\n            threadComputer.updateIndicators(Page.Canvas.setIndicatorText);\r\n        }\r\n\r\n        threadPlotter.plot();\r\n\r\n        if (Parameters.debug) {\r\n            threadComputer.drawDebugView(canvasPlotter.context);\r\n        }\r\n\r\n        requestAnimationFrame(mainLoop);\r\n    }\r\n\r\n    function updateBlur(blur: number): void {\r\n        canvasPlotter.blur = blur;\r\n    }\r\n    Parameters.addBlurChangeObserver(updateBlur);\r\n    updateBlur(Parameters.blur);\r\n\r\n    function onNewImage(image: HTMLImageElement): void {\r\n        Page.Canvas.showLoader(false);\r\n        threadComputer = new ThreadComputer(image);\r\n        threadPlotter = new ThreadPlotter(canvasPlotter, threadComputer);\r\n        needToReset = true;\r\n    }\r\n    Parameters.addFileUploadObserver(onNewImage);\r\n\r\n    Page.Canvas.showLoader(true);\r\n    const defaultImage = new Image();\r\n    defaultImage.addEventListener(\"load\", () => {\r\n        onNewImage(defaultImage);\r\n        requestAnimationFrame(mainLoop);\r\n    });\r\n    defaultImage.src = \"./resources/cat.jpg\";\r\n\r\n    Parameters.addDownloadObserver(() => {\r\n        const svgPlotter = new PlotterSVG();\r\n        const plotter = new ThreadPlotter(svgPlotter, threadComputer);\r\n        plotter.plot();\r\n        const svgString = svgPlotter.export();\r\n        const filename = \"image-as-threading.svg\";\r\n        Helpers.downloadTextFile(svgString, filename);\r\n    });\r\n}\r\n\r\nmain();\r\n","import * as Helpers from \"./helpers\";\r\n\r\nimport \"./page-interface-generated\";\r\n\r\nconst controlId = {\r\n    UPLOAD_INPUT_IMAGE: \"input-image-upload-button\",\r\n    SHAPE: \"shape-tabs-id\",\r\n    PEGS_DENSITY: \"pegs-range-id\",\r\n    NB_LINES: \"lines-range-id\",\r\n    QUALITY: \"quality-tabs-id\",\r\n    MODE: \"thread-mode-tabs-id\",\r\n    LINES_OPACITY: \"opacity-range-id\",\r\n    LINES_THICKNESS: \"thickness-range-id\",\r\n    DISPLAY_PEGS: \"display-pegs-checkbox-id\",\r\n    INVERT_COLORS: \"invert-colors-checkbox-id\",\r\n    SHOW_INDICATORS: \"show-indicators-checkbox-id\",\r\n    BLUR: \"blur-range-id\",\r\n    DOWNLOAD: \"result-download-id\",\r\n};\r\n\r\nenum EShape {\r\n    RECTANGLE = \"0\",\r\n    ELLIPSIS = \"1\",\r\n}\r\n\r\nenum EMode {\r\n    MONOCHROME = \"0\",\r\n    COLORS = \"1\",\r\n}\r\n\r\ntype Observer = () => unknown;\r\nconst redrawObservers: Observer[] = [];\r\nfunction triggerRedraw(): void {\r\n    for (const observer of redrawObservers) {\r\n        observer();\r\n    }\r\n}\r\n\r\nconst resetObservers: Observer[] = [];\r\nfunction triggerReset(): void {\r\n    for (const observer of resetObservers) {\r\n        observer();\r\n    }\r\n}\r\n\r\nPage.Tabs.addObserver(controlId.SHAPE, triggerReset);\r\nPage.Range.addLazyObserver(controlId.PEGS_DENSITY, triggerReset);\r\nPage.Tabs.addObserver(controlId.QUALITY, triggerReset);\r\nPage.Tabs.addObserver(controlId.MODE, triggerReset);\r\nPage.Range.addLazyObserver(controlId.LINES_OPACITY, triggerReset);\r\nPage.Range.addLazyObserver(controlId.LINES_THICKNESS, triggerReset);\r\nPage.Checkbox.addObserver(controlId.DISPLAY_PEGS, triggerRedraw);\r\nPage.Checkbox.addObserver(controlId.INVERT_COLORS, triggerReset);\r\nPage.Canvas.Observers.canvasResize.push(triggerRedraw);\r\n\r\nconst isInDebug = Helpers.getQueryStringValue(\"debug\") === \"1\";\r\n\r\nPage.Canvas.setIndicatorVisibility(\"error-average\", isInDebug);\r\nPage.Canvas.setIndicatorVisibility(\"error-mean-square\", isInDebug);\r\nPage.Canvas.setIndicatorVisibility(\"error-variance\", isInDebug);\r\n\r\nfunction updateIndicatorsVisibility(): void {\r\n    const shouldBeVisible = Page.Checkbox.isChecked(controlId.SHOW_INDICATORS);\r\n    Page.Canvas.setIndicatorsVisibility(shouldBeVisible);\r\n}\r\nPage.Checkbox.addObserver(controlId.SHOW_INDICATORS, updateIndicatorsVisibility);\r\nupdateIndicatorsVisibility();\r\n\r\nabstract class Parameters {\r\n    public static addFileUploadObserver(callback: (image: HTMLImageElement) => unknown): void {\r\n        Page.FileControl.addUploadObserver(controlId.UPLOAD_INPUT_IMAGE, (filesList: FileList) => {\r\n            if (filesList.length === 1) {\r\n                Page.Canvas.showLoader(true);\r\n                const reader = new FileReader();\r\n                reader.onload = () => {\r\n                    const image = new Image();\r\n                    image.addEventListener(\"load\", () => {\r\n                        callback(image);\r\n                    })\r\n                    image.src = reader.result as string;\r\n                };\r\n                reader.readAsDataURL(filesList[0]);\r\n            }\r\n        });\r\n    }\r\n\r\n    public static get debug(): boolean {\r\n        return isInDebug;\r\n    }\r\n\r\n    public static get shape(): EShape {\r\n        return Page.Tabs.getValues(controlId.SHAPE)[0] as EShape;\r\n    }\r\n\r\n    public static get pegsSpacing(): number {\r\n        return 1.1 - Page.Range.getValue(controlId.PEGS_DENSITY);\r\n    }\r\n\r\n    public static get quality(): number {\r\n        return +Page.Tabs.getValues(controlId.QUALITY)[0];\r\n    }\r\n\r\n    public static get mode(): EMode {\r\n        return Page.Tabs.getValues(controlId.MODE)[0] as EMode;\r\n    }\r\n\r\n    public static get nbLines(): number {\r\n        return Page.Range.getValue(controlId.NB_LINES);\r\n    }\r\n\r\n    public static get linesOpacity(): number {\r\n        const raw = Page.Range.getValue(controlId.LINES_OPACITY);\r\n        return Math.pow(2, raw - 7); // 2^(raw+2) / 256\r\n    }\r\n\r\n    public static get linesThickness(): number {\r\n        return Page.Range.getValue(controlId.LINES_THICKNESS);\r\n    }\r\n\r\n    public static get displayPegs(): boolean {\r\n        return Page.Checkbox.isChecked(controlId.DISPLAY_PEGS);\r\n    }\r\n\r\n    public static get invertColors(): boolean {\r\n        return Page.Checkbox.isChecked(controlId.INVERT_COLORS);\r\n    }\r\n\r\n    public static get showIndicators(): boolean {\r\n        return Page.Checkbox.isChecked(controlId.SHOW_INDICATORS);\r\n    }\r\n\r\n    public static addRedrawObserver(callback: Observer): void {\r\n        redrawObservers.push(callback);\r\n    }\r\n\r\n    public static addResetObserver(callback: Observer): void {\r\n        resetObservers.push(callback);\r\n    }\r\n\r\n    public static get blur(): number {\r\n        return Page.Range.getValue(controlId.BLUR);\r\n    }\r\n    public static addBlurChangeObserver(callback: (newBlur: number) => unknown): void {\r\n        Page.Range.addObserver(controlId.BLUR, callback);\r\n    }\r\n\r\n    public static addDownloadObserver(callback: () => unknown): void {\r\n        Page.FileControl.addDownloadObserver(controlId.DOWNLOAD, callback);\r\n    }\r\n}\r\n\r\nexport {\r\n    Parameters,\r\n    EMode,\r\n    EShape,\r\n};\r\n","enum ECompositingOperation {\r\n    DARKEN,\r\n    LIGHTEN,\r\n}\r\n\r\nenum EColor {\r\n    MONOCHROME,\r\n    RED,\r\n    GREEN,\r\n    BLUE,\r\n}\r\n\r\ninterface IColor {\r\n    r: number;\r\n    g: number;\r\n    b: number;\r\n}\r\n\r\nlet supportsAdvancedCompositing = true;\r\nfunction useAdvancedCompositing(): boolean {\r\n    return supportsAdvancedCompositing;\r\n}\r\n\r\nfunction computeRawColor(color: EColor): IColor {\r\n    if (color === EColor.MONOCHROME) {\r\n        return { r: 1, g: 1, b: 1 };\r\n    }\r\n\r\n    const result: IColor = {\r\n        r: (color === EColor.RED) ? 1 : 0,\r\n        g: (color === EColor.GREEN) ? 1 : 0,\r\n        b: (color === EColor.BLUE) ? 1 : 0,\r\n    };\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * @param opacity in [0, 1]\r\n */\r\nfunction applyCanvasCompositing(context: CanvasRenderingContext2D, color: EColor, opacity: number, operation: ECompositingOperation): void {\r\n    if (supportsAdvancedCompositing) {\r\n        const targetOperation = (operation === ECompositingOperation.LIGHTEN) ? \"lighter\" : \"difference\";\r\n        context.globalCompositeOperation = targetOperation;\r\n        if (context.globalCompositeOperation === targetOperation) {\r\n            const value = Math.ceil(255 * opacity);\r\n            const rawRGB = computeRawColor(color);\r\n            context.strokeStyle = `rgb(${rawRGB.r * value}, ${rawRGB.g * value}, ${rawRGB.b * value})`;\r\n            return; // success\r\n        } else {\r\n            supportsAdvancedCompositing = false;\r\n            Page.Demopage.setErrorMessage(\"advanced-compositing-not-supported\", `Your browser does not support canvas2D compositing '${targetOperation}'. The project will not run as expected.`);\r\n        }\r\n    }\r\n\r\n    // basic compositing\r\n    {\r\n        resetCanvasCompositing(context);\r\n        const value = (operation === ECompositingOperation.LIGHTEN) ? 255 : 0;\r\n        const rawRGB = computeRawColor(color);\r\n        context.strokeStyle = `rgba(${rawRGB.r * value}, ${rawRGB.g * value}, ${rawRGB.b * value}, ${opacity})`;\r\n    }\r\n}\r\n\r\nfunction resetCanvasCompositing(context: CanvasRenderingContext2D): void {\r\n    context.globalCompositeOperation = \"source-over\";\r\n}\r\n\r\nexport {\r\n    EColor,\r\n    ECompositingOperation,\r\n    applyCanvasCompositing,\r\n    computeRawColor,\r\n    resetCanvasCompositing,\r\n    useAdvancedCompositing,\r\n};\r\n","import { ILine } from \"../interfaces/i-line\";\r\nimport { IPoint } from \"../interfaces/i-point\";\r\nimport { ISize } from \"../interfaces/i-size\";\r\nimport { EColor, ECompositingOperation } from \"./compositing\";\r\n\r\ninterface IPlotterInfo {\r\n    backgroundColor: string;\r\n    blur: number;\r\n}\r\n\r\ninterface IImageFitting {\r\n    sizeInPlotter: ISize;\r\n    imageRelativeToCanvasPixel: (relativeCoords: IPoint) => IPoint;\r\n};\r\n\r\nabstract class PlotterBase {\r\n    public abstract resize(): void;\r\n    public abstract initialize(infos: IPlotterInfo): void;\r\n    public abstract finalize(): void;\r\n\r\n    public abstract drawLines(lines: ILine[], color: EColor, opacity: number, operation: ECompositingOperation, thickness: number): void;\r\n    public abstract drawPoints(points: IPoint[], color: string, diameter: number): void;\r\n\r\n    public abstract get size(): ISize;\r\n\r\n    public drawBrokenLine(points: IPoint[], color: EColor, opacity: number, operation: ECompositingOperation, thickness: number): void {\r\n        const lines: ILine[] = [];\r\n\r\n        for (let i = 0; i < points.length - 1; i++) {\r\n            lines.push({ from: points[i], to: points[i + 1] });\r\n        }\r\n        this.drawLines(lines, color, opacity, operation, thickness);\r\n    }\r\n}\r\n\r\nexport { PlotterBase, IImageFitting, IPlotterInfo, ISize }\r\n","import { PlotterBase, IPlotterInfo } from \"./plotter-base\";\r\nimport { IPoint } from \"../interfaces/i-point\";\r\nimport { ISize } from \"../interfaces/i-size\";\r\n\r\nimport \"../page-interface-generated\";\r\nimport { ILine } from \"../interfaces/i-line\";\r\nimport { applyCanvasCompositing, EColor, ECompositingOperation, resetCanvasCompositing } from \"./compositing\";\r\n\r\nclass PlotterCanvas2D extends PlotterBase {\r\n    private readonly canvas: HTMLCanvasElement;\r\n    public readonly context: CanvasRenderingContext2D;\r\n    private readonly cssPixel: number;\r\n\r\n    public constructor() {\r\n        super();\r\n\r\n        this.canvas = Page.Canvas.getCanvas();\r\n        this.context = this.canvas.getContext(\"2d\", { alpha: false });\r\n        this.cssPixel = window.devicePixelRatio ?? 1;\r\n    }\r\n\r\n    public resize(): void {\r\n        const actualWidth = Math.floor(this.cssPixel * this.canvas.clientWidth);\r\n        const actualHeight = Math.floor(this.cssPixel * this.canvas.clientHeight);\r\n\r\n        if (this.canvas.width !== actualWidth || this.canvas.height !== actualHeight) {\r\n            this.canvas.width = actualWidth;\r\n            this.canvas.height = actualHeight;\r\n        }\r\n    }\r\n\r\n    public initialize(infos: IPlotterInfo): void {\r\n        this.context.fillStyle = infos.backgroundColor;\r\n        this.context.lineJoin = \"round\";\r\n        resetCanvasCompositing(this.context);\r\n        this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n\r\n    // tslint:disable-next-line:no-empty\r\n    public finalize(): void { }\r\n\r\n    public set blur(value: number) {\r\n        if (value === 0) {\r\n            this.canvas.style.filter = \"\";\r\n        } else {\r\n            this.canvas.style.filter = `blur(${value}px)`; // simple blur supported everywhere but with artifacts on the edges\r\n            // artifact-free blur, but not supported everywhere\r\n            this.canvas.style.filter = `url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='a' x='0' y='0' width='1' height='1'%3E%3CfeGaussianBlur stdDeviation='${value}' result='b'/%3E%3CfeMorphology operator='dilate' radius='${value}'/%3E %3CfeMerge%3E%3CfeMergeNode/%3E%3CfeMergeNode in='b'/%3E%3C/feMerge%3E%3C/filter%3E%3C/svg%3E#a\")`;\r\n        }\r\n    }\r\n\r\n    public drawLines(lines: ILine[], color: EColor, opacity: number, operation: ECompositingOperation, thickness: number): void {\r\n        if (lines.length >= 1) {\r\n            applyCanvasCompositing(this.context, color, opacity, operation);\r\n\r\n            this.context.lineWidth = thickness * this.cssPixel;\r\n\r\n            for (const line of lines) {\r\n                this.context.beginPath();\r\n                this.context.moveTo(line.from.x * this.cssPixel, line.from.y * this.cssPixel);\r\n                this.context.lineTo(line.to.x * this.cssPixel, line.to.y * this.cssPixel);\r\n                this.context.stroke();\r\n                this.context.closePath();\r\n            }\r\n\r\n            resetCanvasCompositing(this.context);\r\n        }\r\n    }\r\n\r\n    public drawPoints(points: IPoint[], color: string, diameter: number): void {\r\n        if (points.length > 0) {\r\n            this.context.fillStyle = color;\r\n            this.context.strokeStyle = \"none\";\r\n\r\n            for (const point of points) {\r\n                this.context.beginPath();\r\n                this.context.arc(point.x * this.cssPixel, point.y * this.cssPixel, 0.5 * diameter * this.cssPixel, 0, 2 * Math.PI);\r\n                this.context.fill();\r\n                this.context.closePath();\r\n            }\r\n        }\r\n    }\r\n\r\n    public get size(): ISize {\r\n        return {\r\n            width: Math.floor(this.canvas.width / this.cssPixel),\r\n            height: Math.floor(this.canvas.height / this.cssPixel),\r\n        };\r\n    }\r\n}\r\n\r\nexport { PlotterCanvas2D }\r\n","import { ILine } from \"../interfaces/i-line\";\r\nimport { IPoint } from \"../interfaces/i-point\";\r\nimport { computeRawColor, EColor, ECompositingOperation, useAdvancedCompositing } from \"./compositing\";\r\nimport { PlotterBase, IPlotterInfo, ISize } from \"./plotter-base\";\r\nimport { XMLWriter } from \"./xml-writer\";\r\n\r\nconst WIDTH = 1000;\r\nconst HEIGHT = 1000;\r\n\r\nconst BLUR_EFFECT_ID = \"gaussianBlur\";\r\n\r\nclass PlotterSVG extends PlotterBase {\r\n    private hasBlur: boolean;\r\n    private writer: XMLWriter;\r\n\r\n    public constructor() {\r\n        super();\r\n    }\r\n\r\n    // tslint:disable-next-line:no-empty\r\n    public resize(): void {\r\n    }\r\n\r\n    public initialize(infos: IPlotterInfo): void {\r\n        this.writer = new XMLWriter();\r\n\r\n        this.hasBlur = infos.blur > 0;\r\n\r\n        this.writer.addLine(`<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>`);\r\n        this.writer.startBlock(`<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" viewBox=\"0 0 ${WIDTH} ${HEIGHT}\">`);\r\n\r\n        if (this.hasBlur) {\r\n            this.writer.startBlock(`<defs>`);\r\n            this.writer.startBlock(`<filter id=\"${BLUR_EFFECT_ID}\" x=\"0\" y=\"0\">`);\r\n            this.writer.addLine(`<feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"${infos.blur}\"/>`);\r\n            this.writer.endBlock(`</filter>`);\r\n            this.writer.endBlock(`</defs>`);\r\n\r\n            this.writer.startBlock(`<g filter=\"url(#${BLUR_EFFECT_ID})\">`);\r\n\r\n        }\r\n\r\n        const margin = 10;\r\n        this.writer.addLine(`<rect fill=\"white\" stroke=\"none\" x=\"${-margin}\" y=\"${-margin}\" width=\"${WIDTH + 2 * margin}\" height=\"${HEIGHT + 2 * margin}\"/>`);\r\n    }\r\n\r\n    public finalize(): void {\r\n        if (this.hasBlur) {\r\n            this.writer.endBlock(`</g>`);\r\n        }\r\n        this.writer.endBlock(`</svg>`);\r\n    }\r\n\r\n    public drawLines(lines: ILine[], color: EColor, opacity: number, operation: ECompositingOperation, thickness: number): void {\r\n        if (lines.length >= 1) {\r\n\r\n            let strokeColor: string;\r\n            if (useAdvancedCompositing()) {\r\n                this.writer.startBlock(`<defs>`);\r\n                this.writer.startBlock(`<style type=\"text/css\">`);\r\n                this.writer.startBlock(`<![CDATA[`);\r\n                this.writer.addLine(`line { mix-blend-mode: difference; }`);\r\n                if (operation === ECompositingOperation.LIGHTEN) {\r\n                    this.writer.addLine(`svg { filter: invert(1); background: black; }`);\r\n                }\r\n                this.writer.endBlock(`]]>`);\r\n                this.writer.endBlock(`</style>`);\r\n                this.writer.endBlock(`</defs>`);\r\n\r\n                const value = Math.ceil(255 * opacity);\r\n                const rawRGB = computeRawColor(color);\r\n                strokeColor = `rgb(${rawRGB.r * value}, ${rawRGB.g * value}, ${rawRGB.b * value})`;\r\n            } else {\r\n                const value = (useAdvancedCompositing()) ? 255 : 0;\r\n                const rawRGB = computeRawColor(color);\r\n                strokeColor = `rgba(${rawRGB.r * value}, ${rawRGB.g * value}, ${rawRGB.b * value}, ${opacity})`;\r\n            }\r\n\r\n            // lines container\r\n            this.writer.startBlock(`<g stroke=\"${strokeColor}\" stroke-width=\"${thickness}\" stroke-linecap=\"round\" fill=\"none\">`);\r\n            for (const line of lines) {\r\n                this.writer.addLine(`<line x1=\"${line.from.x.toFixed(1)}\" y1=\"${line.from.y.toFixed(1)}\" x2=\"${line.to.x.toFixed(1)}\" y2=\"${line.to.y.toFixed(1)}\"/>`);\r\n            }\r\n            this.writer.endBlock(`</g>`);\r\n        }\r\n    }\r\n\r\n    public drawPoints(points: IPoint[], color: string, diameter: number): void {\r\n        if (points.length > 0) {\r\n            this.writer.startBlock(`<g fill=\"${color}\" stroke=\"none\">`);\r\n            for (const point of points) {\r\n                this.writer.addLine(`<circle cx=\"${point.x.toFixed(1)}\" cy=\"${point.y.toFixed(1)}\" r=\"${0.5 * diameter}\"/>`);\r\n            }\r\n            this.writer.endBlock(`</g>`);\r\n        }\r\n    }\r\n\r\n    public export(): string {\r\n        const start = Date.now();\r\n        const result = this.writer.result;\r\n        console.log(`Concatenation took ${Date.now() - start} ms.`);\r\n        return result;\r\n    }\r\n\r\n    public get size(): ISize {\r\n        return {\r\n            width: WIDTH,\r\n            height: HEIGHT,\r\n        };\r\n    }\r\n}\r\n\r\nexport { PlotterSVG }\r\n","class XMLWriter {\r\n    private indentationLevel: number = 0;\r\n    private lines: string[] = [];\r\n\r\n    public get result(): string {\r\n        return this.lines.join(\"\\n\");\r\n    }\r\n\r\n    public startBlock(line: string): void {\r\n        this.addLine(line);\r\n        this.indentationLevel++;\r\n    }\r\n\r\n    public endBlock(line: string): void {\r\n        this.indentationLevel--;\r\n        this.addLine(line);\r\n    }\r\n\r\n    public addLine(line: string): void {\r\n        this.lines.push(this.prefix + line);\r\n    }\r\n\r\n    private get prefix(): string {\r\n        return \"\\t\".repeat(this.indentationLevel);\r\n    }\r\n}\r\n\r\nexport { XMLWriter };\r\n","import { IPoint } from \"../interfaces/i-point\";\r\nimport { ISize } from \"../interfaces/i-size\";\r\nimport { EMode, EShape, Parameters } from \"../parameters\";\r\nimport { PlotterBase } from \"../plotter/plotter-base\";\r\nimport { Transformation } from \"./transformation\";\r\nimport { applyCanvasCompositing, EColor, ECompositingOperation, resetCanvasCompositing } from \"../plotter/compositing\";\r\n\r\nimport { ThreadMonochrome } from \"./thread/thread-monochrome\";\r\nimport { ThreadRedBlueGreen } from \"./thread/thread-red-green-blue\";\r\nimport { ThreadBase } from \"./thread/thread-base\";\r\n\r\nconst MIN_SAFE_NUMBER = -9007199254740991;\r\nconst TWO_PI = 2 * Math.PI;\r\n\r\nfunction clamp(x: number, min: number, max: number): number {\r\n    if (x < min) {\r\n        return min;\r\n    } else if (x > max) {\r\n        return max;\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction mix(a: number, b: number, x: number): number {\r\n    return a * (1 - x) + b * x;\r\n}\r\n\r\nfunction distance(p1: IPoint, p2: IPoint): number {\r\n    const dX = p1.x - p2.x;\r\n    const dY = p1.y - p2.y;\r\n    return Math.sqrt(dX * dX + dY * dY);\r\n}\r\n\r\nfunction randomItem<T>(list: T[]): T {\r\n    if (list.length === 0) {\r\n        return null;\r\n    }\r\n    const randomIndex = Math.floor(Math.random() * list.length);\r\n    return list[randomIndex];\r\n}\r\n\r\ninterface IPeg {\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\ninterface ISegment {\r\n    peg1: IPeg;\r\n    peg2: IPeg;\r\n}\r\n\r\ninterface IErrorMeasure {\r\n    average: number;\r\n    variance: number;\r\n    meanSquare: number;\r\n}\r\n\r\ntype IndicatorUpdateFunction = (indicatorId: string, indicatorValue: string) => unknown;\r\n\r\n/**\r\n * Class used to compute which thread path is the best choice.\r\n */\r\nclass ThreadComputer {\r\n    private readonly sourceImage: HTMLImageElement;\r\n    private readonly hiddenCanvas: HTMLCanvasElement;\r\n    private readonly hiddenCanvasContext: CanvasRenderingContext2D;\r\n    private hiddenCanvasData: ImageData = null\r\n    private hiddenCanvasScale: number;\r\n\r\n    private error: IErrorMeasure;\r\n\r\n    private pegs: IPeg[];\r\n\r\n    private lineOpacity: number; // in the final result\r\n    private lineOpacityInternal: number;\r\n    private lineThickness: number; // abstract unit\r\n\r\n    private thread: ThreadBase;\r\n\r\n    private arePegsTooClose: (peg1: IPeg, peg2: IPeg) => boolean;\r\n\r\n    public constructor(image: HTMLImageElement) {\r\n        this.sourceImage = image;\r\n\r\n        this.hiddenCanvas = document.createElement(\"canvas\");\r\n        this.hiddenCanvasContext = this.hiddenCanvas.getContext(\"2d\");\r\n\r\n        this.reset(16 / 256, 1);\r\n    }\r\n\r\n    public drawThread(plotter: PlotterBase, nbSegmentsToIgnore: number): void {\r\n        const transformation = this.computeTransformation(plotter.size);\r\n        const lineWidth = (transformation.scaling * this.hiddenCanvasScale) * this.lineThickness;\r\n        const compositing = Parameters.invertColors ? ECompositingOperation.LIGHTEN : ECompositingOperation.DARKEN;\r\n\r\n        this.thread.iterateOnThreads(nbSegmentsToIgnore, (thread: IPeg[], color: EColor) => {\r\n            const points: IPoint[] = [];\r\n            for (const peg of thread) {\r\n                points.push(transformation.transform(peg));\r\n            }\r\n\r\n            plotter.drawBrokenLine(points, color, this.lineOpacity, compositing, lineWidth);\r\n        });\r\n    }\r\n\r\n    public drawPegs(plotter: PlotterBase): void {\r\n        const transformation = this.computeTransformation(plotter.size);\r\n        const pointSize = 0.5 * (transformation.scaling * this.hiddenCanvasScale);\r\n\r\n        const points: IPoint[] = [];\r\n        for (const peg of this.pegs) {\r\n            points.push(transformation.transform(peg));\r\n        }\r\n\r\n        plotter.drawPoints(points, \"red\", pointSize);\r\n    }\r\n\r\n    public drawDebugView(targetContext: CanvasRenderingContext2D): void {\r\n        targetContext.drawImage(this.hiddenCanvas, 0, 0, this.hiddenCanvas.width, this.hiddenCanvas.height);\r\n    }\r\n\r\n    /** Returns true if there is nothing more to compute */\r\n    public computeNextSegments(maxMillisecondsTaken: number): boolean {\r\n        const start = performance.now();\r\n\r\n        const targetNbSegments = Parameters.nbLines;\r\n        if (this.nbSegments === targetNbSegments) {\r\n            // no new segment to compute\r\n            return false;\r\n        } else if (this.nbSegments > targetNbSegments) {\r\n            // we drew too many lines already, removes the excess\r\n            this.thread.lowerNbSegments(targetNbSegments);\r\n\r\n            // redraw the hidden canvas from scratch\r\n            this.resetHiddenCanvas();\r\n            this.thread.iterateOnThreads(0, (thread: IPeg[], color: EColor) => {\r\n                applyCanvasCompositing(this.hiddenCanvasContext, color, this.lineOpacityInternal, ECompositingOperation.LIGHTEN);\r\n\r\n                for (let iPeg = 0; iPeg + 1 < thread.length; iPeg++) {\r\n                    this.drawSegmentOnHiddenCanvas(thread[iPeg], thread[iPeg + 1]);\r\n                }\r\n            });\r\n\r\n            this.computeError();\r\n            return true;\r\n        }\r\n\r\n        let lastColor: EColor = null;\r\n        while (this.nbSegments < targetNbSegments && performance.now() - start < maxMillisecondsTaken) {\r\n            const threadToGrow = this.thread.getThreadToGrow();\r\n\r\n            if (lastColor !== threadToGrow.color) {\r\n                applyCanvasCompositing(this.hiddenCanvasContext, threadToGrow.color, this.lineOpacityInternal, ECompositingOperation.LIGHTEN);\r\n                this.thread.enableSamplingFor(threadToGrow.color);\r\n                lastColor = threadToGrow.color;\r\n            }\r\n            this.computeSegment(threadToGrow.thread);\r\n\r\n            if (this.nbSegments % 100 === 0) {\r\n                this.computeError();\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @param opacity in [0,1]\r\n     * @returns true if at least one parameter changed\r\n     */\r\n    public reset(opacity: number, linethickness: number): void {\r\n        this.lineOpacity = opacity;\r\n        this.lineThickness = linethickness;\r\n\r\n        this.hiddenCanvasScale = Parameters.quality;\r\n\r\n        if (Parameters.mode === EMode.MONOCHROME) {\r\n            this.thread = new ThreadMonochrome();\r\n        } else {\r\n            this.thread = new ThreadRedBlueGreen();\r\n        }\r\n        this.resetHiddenCanvas();\r\n\r\n        this.pegs = this.computePegs();\r\n    }\r\n\r\n    public updateIndicators(updateFunction: IndicatorUpdateFunction): void {\r\n        updateFunction(\"pegs-count\", this.pegs.length.toString());\r\n        updateFunction(\"segments-count\", this.nbSegments.toString());\r\n        updateFunction(\"error-average\", this.error.average.toString());\r\n        updateFunction(\"error-mean-square\", this.error.meanSquare.toString());\r\n        updateFunction(\"error-variance\", this.error.variance.toString());\r\n    }\r\n\r\n    public get nbSegments(): number {\r\n        return this.thread.totalNbSegments;\r\n    }\r\n\r\n    private initializeHiddenCanvasLineProperties(): void {\r\n        const theoricalThicknes = this.lineThickness * this.hiddenCanvasScale;\r\n\r\n        if (theoricalThicknes <= 1) {\r\n            // do not go below a line width of 1 because it creates artifact.\r\n            // instead, lower the lines opacity.\r\n            this.lineOpacityInternal = 0.5 * this.lineOpacity * theoricalThicknes;\r\n            this.hiddenCanvasContext.lineWidth = 1;\r\n        } else {\r\n            this.lineOpacityInternal = 0.5 * this.lineOpacity;\r\n            this.hiddenCanvasContext.lineWidth = theoricalThicknes;\r\n        }\r\n    }\r\n\r\n    private computeSegment(thread: IPeg[]): void {\r\n        let lastPeg: IPeg;\r\n        let nextPeg: IPeg;\r\n\r\n        if (thread.length === 0) {\r\n            const startingSegment = this.computeBestStartingSegment();\r\n            thread.push(startingSegment.peg1);\r\n            lastPeg = startingSegment.peg1;\r\n            nextPeg = startingSegment.peg2;\r\n        } else {\r\n            lastPeg = thread[thread.length - 1];\r\n            const HISTORY_SIZE = Math.min(thread.length, 20);\r\n            const prevousPegs = thread.slice(-HISTORY_SIZE);\r\n            nextPeg = this.computeBestNextPeg(lastPeg, prevousPegs);\r\n        }\r\n\r\n        thread.push(nextPeg);\r\n        this.drawSegmentOnHiddenCanvas(lastPeg, nextPeg);\r\n    }\r\n\r\n    private resetHiddenCanvas(): void {\r\n        const wantedSize = ThreadComputer.computeBestSize(this.sourceImage, 100 * this.hiddenCanvasScale);\r\n        this.hiddenCanvas.width = wantedSize.width;\r\n        this.hiddenCanvas.height = wantedSize.height;\r\n\r\n        resetCanvasCompositing(this.hiddenCanvasContext);\r\n        this.hiddenCanvasContext.drawImage(this.sourceImage, 0, 0, wantedSize.width, wantedSize.height);\r\n\r\n        // change the base level so that pure white becomes medium grey\r\n        const imageData = this.hiddenCanvasContext.getImageData(0, 0, wantedSize.width, wantedSize.height);\r\n        this.thread.adjustCanvasData(imageData.data, Parameters.invertColors);\r\n        this.hiddenCanvasContext.putImageData(imageData, 0, 0);\r\n        this.computeError();\r\n\r\n        this.initializeHiddenCanvasLineProperties();\r\n    }\r\n\r\n    private computeError(): void {\r\n        this.uploadCanvasDataToCPU();\r\n\r\n        this.error = {\r\n            average: 0,\r\n            variance: 0,\r\n            meanSquare: 0,\r\n        };\r\n\r\n        const nbPixels = this.hiddenCanvasData.width * this.hiddenCanvasData.height;\r\n        const nbSamples = 3 * nbPixels;\r\n        for (let iP = 0; iP < nbPixels; iP++) {\r\n            const errorRed = 127 - this.hiddenCanvasData.data[4 * iP + 0];\r\n            const errorGreen = 127 - this.hiddenCanvasData.data[4 * iP + 1];\r\n            const errorBlue = 127 - this.hiddenCanvasData.data[4 * iP + 2];\r\n\r\n            this.error.average += errorRed + errorGreen + errorBlue;\r\n            this.error.meanSquare += (errorRed * errorRed) + (errorGreen * errorGreen) + (errorBlue * errorBlue);\r\n        }\r\n        this.error.average = Math.round(this.error.average / nbSamples);\r\n        this.error.meanSquare = Math.round(this.error.meanSquare / nbSamples);\r\n\r\n        for (let iP = 0; iP < nbPixels; iP++) {\r\n            const errorRed = 127 - this.hiddenCanvasData.data[4 * iP + 0];\r\n            const errorGreen = 127 - this.hiddenCanvasData.data[4 * iP + 1];\r\n            const errorBlue = 127 - this.hiddenCanvasData.data[4 * iP + 2];\r\n            const error = (errorRed + errorGreen + errorBlue) / 3;\r\n            const distancetoError = error - this.error.average;\r\n            this.error.variance += distancetoError * distancetoError;\r\n        }\r\n        this.error.variance = Math.round(this.error.variance / nbSamples);\r\n    }\r\n\r\n    private computeTransformation(targetSize: ISize): Transformation {\r\n        return new Transformation(targetSize, this.hiddenCanvas);\r\n    }\r\n\r\n    private drawSegmentOnHiddenCanvas(peg1: IPeg, peg2: IPeg): void {\r\n        this.hiddenCanvasContext.beginPath();\r\n        this.hiddenCanvasContext.moveTo(peg1.x, peg1.y);\r\n        this.hiddenCanvasContext.lineTo(peg2.x, peg2.y);\r\n        this.hiddenCanvasContext.stroke();\r\n        this.hiddenCanvasContext.closePath();\r\n\r\n        // invalidate CPU data\r\n        this.hiddenCanvasData = null;\r\n    }\r\n\r\n    private computeBestStartingSegment(): ISegment {\r\n        let candidates: ISegment[] = [];\r\n        let bestScore = MIN_SAFE_NUMBER;\r\n\r\n        const step = 1 + Math.floor(this.pegs.length / 100);\r\n        for (let iPegId1 = 0; iPegId1 < this.pegs.length; iPegId1 += step) {\r\n            for (let iPegId2 = iPegId1 + 1; iPegId2 < this.pegs.length; iPegId2 += step) {\r\n                const peg1 = this.pegs[iPegId1];\r\n                const peg2 = this.pegs[iPegId2];\r\n\r\n                if (!this.arePegsTooClose(peg1, peg2)) {\r\n                    const candidateScore = this.computeSegmentPotential(peg1, peg2);\r\n                    if (candidateScore > bestScore) {\r\n                        bestScore = candidateScore;\r\n                        candidates = [{ peg1, peg2, }];\r\n                    } else if (candidateScore === bestScore) {\r\n                        candidates.push({ peg1, peg2, });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return randomItem(candidates);\r\n    }\r\n\r\n    private computeBestNextPeg(currentPeg: IPeg, pegsToAvoid: IPeg[]): IPeg {\r\n        let candidates: IPeg[] = [];\r\n        let bestScore = MIN_SAFE_NUMBER;\r\n\r\n        for (const peg of this.pegs) {\r\n            if (!this.arePegsTooClose(currentPeg, peg) && !pegsToAvoid.includes(peg)) {\r\n                const candidateScore = this.computeSegmentPotential(currentPeg, peg);\r\n                if (candidateScore > bestScore) {\r\n                    bestScore = candidateScore;\r\n                    candidates = [peg];\r\n                } else if (candidateScore === bestScore) {\r\n                    candidates.push(peg);\r\n                }\r\n            }\r\n        }\r\n\r\n        return randomItem(candidates);\r\n    }\r\n\r\n    private uploadCanvasDataToCPU(): void {\r\n        if (this.hiddenCanvasData === null) {\r\n            const width = this.hiddenCanvas.width;\r\n            const height = this.hiddenCanvas.height;\r\n            this.hiddenCanvasData = this.hiddenCanvasContext.getImageData(0, 0, width, height);\r\n        }\r\n    }\r\n\r\n    /* The higher the result, the better a choice the thread is. */\r\n    private computeSegmentPotential(peg1: IPeg, peg2: IPeg): number {\r\n        this.uploadCanvasDataToCPU();\r\n\r\n        let potential = 0;\r\n\r\n        const segmentLength = distance(peg1, peg2);\r\n        const nbSamples = Math.ceil(segmentLength);\r\n        for (let iSample = 0; iSample < nbSamples; iSample++) {\r\n            const r = (iSample + 1) / (nbSamples + 1);\r\n            const sample: IPoint = {\r\n                x: mix(peg1.x, peg2.x, r),\r\n                y: mix(peg1.y, peg2.y, r),\r\n            };\r\n\r\n            const imageValue = this.sampleCanvasData(sample);\r\n            const finalValue = imageValue + (this.lineOpacityInternal * 255);\r\n            const contribution = 127 - finalValue;\r\n            potential += contribution;\r\n        }\r\n\r\n        return potential / nbSamples;\r\n    }\r\n\r\n    /** Linear interpolation. Returns a result in [0, 255] */\r\n    private sampleCanvasData(coords: IPoint): number {\r\n        const width = this.hiddenCanvasData.width;\r\n        const height = this.hiddenCanvasData.height;\r\n\r\n        const minX = clamp(Math.floor(coords.x), 0, width - 1);\r\n        const maxX = clamp(Math.ceil(coords.x), 0, width - 1);\r\n        const minY = clamp(Math.floor(coords.y), 0, height - 1);\r\n        const maxY = clamp(Math.ceil(coords.y), 0, height - 1);\r\n\r\n        const topLeft = this.sampleCanvasPixel(minX, minY);\r\n        const topRight = this.sampleCanvasPixel(maxX, minY);\r\n        const bottomLeft = this.sampleCanvasPixel(minX, maxY);\r\n        const bottomRight = this.sampleCanvasPixel(maxX, maxY);\r\n\r\n        const fractX = coords.x % 1;\r\n        const top = mix(topLeft, topRight, fractX);\r\n        const bottom = mix(bottomLeft, bottomRight, fractX);\r\n\r\n        const fractY = coords.y % 1;\r\n        return mix(top, bottom, fractY);\r\n    }\r\n\r\n    private sampleCanvasPixel(pixelX: number, pixelY: number): number {\r\n        const index = 4 * (pixelX + pixelY * this.hiddenCanvasData.width);\r\n        return this.thread.sampleCanvas(this.hiddenCanvasData.data, index);\r\n    }\r\n\r\n    private static computeBestSize(sourceImageSize: ISize, maxSize: number): ISize {\r\n        const maxSourceSide = Math.max(sourceImageSize.width, sourceImageSize.height);\r\n        const sizingFactor = maxSize / maxSourceSide;\r\n        return {\r\n            width: Math.ceil(sourceImageSize.width * sizingFactor),\r\n            height: Math.ceil(sourceImageSize.height * sizingFactor),\r\n        };\r\n    }\r\n\r\n    private computePegs(): IPeg[] {\r\n        /* First, compute pegs for a fixed-size canvas*/\r\n        let domainSize: ISize;\r\n        {\r\n            const DEFAULT_CANVAS_SIZE_FOR_PEGS = 1000;\r\n            const aspectRatio = this.hiddenCanvas.width / this.hiddenCanvas.height;\r\n            if (aspectRatio > 1) {\r\n                domainSize = { width: DEFAULT_CANVAS_SIZE_FOR_PEGS, height: Math.round(DEFAULT_CANVAS_SIZE_FOR_PEGS / aspectRatio) };\r\n            } else {\r\n                domainSize = { width: Math.round(DEFAULT_CANVAS_SIZE_FOR_PEGS * aspectRatio), height: DEFAULT_CANVAS_SIZE_FOR_PEGS };\r\n            }\r\n        }\r\n        const pegsShape = Parameters.shape;\r\n        const pegsSpacing = 20 * Parameters.pegsSpacing;\r\n\r\n        const pegs: IPeg[] = [];\r\n\r\n        if (pegsShape === EShape.RECTANGLE) {\r\n            this.arePegsTooClose = (peg1: IPeg, peg2: IPeg) => {\r\n                return peg1.x === peg2.x || peg1.y === peg2.y;\r\n            };\r\n\r\n            const maxX = domainSize.width;\r\n            const maxY = domainSize.height;\r\n\r\n            // corners\r\n            pegs.push({ x: 0, y: 0 });\r\n            pegs.push({ x: maxX, y: 0 });\r\n            pegs.push({ x: maxX, y: maxY });\r\n            pegs.push({ x: 0, y: maxY });\r\n\r\n            // sides\r\n            const nbPegsPerWidth = Math.ceil(domainSize.width / pegsSpacing);\r\n            for (let iW = 1; iW < nbPegsPerWidth; iW++) {\r\n                const x = maxX * (iW / nbPegsPerWidth);\r\n                pegs.push({ x, y: 0 });\r\n                pegs.push({ x, y: maxY });\r\n            }\r\n\r\n            const nbPegsPerHeight = Math.ceil(domainSize.height / pegsSpacing);\r\n            for (let iH = 1; iH < nbPegsPerHeight; iH++) {\r\n                const y = maxY * (iH / nbPegsPerHeight);\r\n                pegs.push({ x: 0, y });\r\n                pegs.push({ x: maxX, y });\r\n            }\r\n        } else {\r\n            interface IPegCircle extends IPeg {\r\n                angle: number;\r\n            }\r\n\r\n            this.arePegsTooClose = (peg1: IPeg, peg2: IPeg) => {\r\n                const absDeltaAngle = Math.abs((peg1 as IPegCircle).angle - (peg2 as IPegCircle).angle);\r\n                const minAngle = Math.min(absDeltaAngle, TWO_PI - absDeltaAngle);\r\n                return minAngle <= TWO_PI / 16;\r\n            };\r\n\r\n            const maxSize = Math.max(domainSize.width, domainSize.height);\r\n            const nbPegs = Math.ceil(0.5 * TWO_PI * maxSize / pegsSpacing);\r\n            const baseDeltaAngle = TWO_PI / nbPegs;\r\n            for (let iPeg = 0; iPeg < nbPegs; iPeg++) {\r\n                const angle = iPeg * baseDeltaAngle;\r\n                const peg: IPegCircle = {\r\n                    x: 0.5 * domainSize.width * (1 + Math.cos(angle)),\r\n                    y: 0.5 * domainSize.height * (1 + Math.sin(angle)),\r\n                    angle,\r\n                }\r\n                pegs.push(peg);\r\n            }\r\n        }\r\n\r\n        /* Then adjust the pegs to the actual canvas size */\r\n        for (const peg of pegs) {\r\n            peg.x *= this.hiddenCanvas.width / domainSize.width;\r\n            peg.y *= this.hiddenCanvas.height / domainSize.height;\r\n        }\r\n\r\n        return pegs;\r\n    }\r\n}\r\n\r\nexport { ThreadComputer, IPeg };\r\n","import { Parameters } from \"../parameters\";\r\nimport { IPlotterInfo, PlotterBase } from \"../plotter/plotter-base\";\r\nimport { ThreadComputer } from \"./thread-computer\";\r\n\r\nclass ThreadPlotter {\r\n    private nbSegmentsDrawn: number = 0;\r\n\r\n    public constructor(private readonly plotter: PlotterBase, private readonly threadComputer: ThreadComputer) { }\r\n\r\n    public reset(): void {\r\n        this.nbSegmentsDrawn = 0;\r\n    }\r\n\r\n    public plot(): void {\r\n        if (this.nbSegmentsDrawn === this.threadComputer.nbSegments) {\r\n            // nothing more to do\r\n            return;\r\n        } else if (this.nbSegmentsDrawn > this.threadComputer.nbSegments) {\r\n            // if the nb of segment went down, no other choice that redrawing all from scratch\r\n            this.nbSegmentsDrawn = 0;\r\n        }\r\n\r\n        const drawFromScratch = (this.nbSegmentsDrawn === 0);\r\n        if (drawFromScratch) {\r\n            const plotterInfos: IPlotterInfo = {\r\n                backgroundColor: Parameters.invertColors ? \"black\" : \"white\",\r\n                blur: Parameters.blur,\r\n            };\r\n\r\n            this.plotter.resize();\r\n            this.plotter.initialize(plotterInfos);\r\n\r\n            if (Parameters.displayPegs) {\r\n                this.threadComputer.drawPegs(this.plotter);\r\n            }\r\n\r\n            this.threadComputer.drawThread(this.plotter, 0);\r\n            this.plotter.finalize();\r\n        } else {\r\n            this.threadComputer.drawThread(this.plotter, this.nbSegmentsDrawn);\r\n        }\r\n\r\n        this.nbSegmentsDrawn = this.threadComputer.nbSegments;\r\n    }\r\n}\r\n\r\nexport { ThreadPlotter };\r\n","import { EColor } from \"../../plotter/compositing\";\r\nimport { IPeg } from \"../thread-computer\";\r\n\r\ntype ThreadsIterator = (thread: IPeg[], color: EColor) => unknown;\r\n\r\ntype SamplingFunction = (data: Uint8ClampedArray, index: number) => number;\r\n\r\ninterface IThreadToGrow {\r\n    thread: IPeg[];\r\n    color: EColor;\r\n}\r\n\r\nabstract class ThreadBase {\r\n    public abstract get totalNbSegments(): number;\r\n\r\n    public abstract lowerNbSegments(targetNumber: number): void;\r\n\r\n    public abstract iterateOnThreads(nbSegmentsToIgnore: number, callback: ThreadsIterator): void;\r\n\r\n    public abstract getThreadToGrow(): IThreadToGrow;\r\n\r\n    public abstract adjustCanvasData(data: Uint8ClampedArray, blackBackground: boolean): void;\r\n\r\n    public abstract enableSamplingFor(color: EColor): void;\r\n\r\n    /**\r\n     * @returns value in [0, 255]. Ideal value is 127\r\n     */\r\n    public sampleCanvas: SamplingFunction = null;\r\n\r\n    protected static lowerNbSegmentsForThread(thread: IPeg[], targetNumber: number): void {\r\n        if (targetNumber > 0) {\r\n            thread.length = Math.min(thread.length, targetNumber + 1);\r\n        } else {\r\n            thread.length = 0;\r\n        }\r\n    }\r\n\r\n    protected static computeNbSegments(thread: IPeg[]): number {\r\n        return (thread.length > 1) ? thread.length - 1 : 0;\r\n    }\r\n\r\n    public static iterateOnThread(thread: IPeg[], color: EColor, fromSegmentNumber: number, callback: ThreadsIterator): void {\r\n        const threadLength = ThreadBase.computeNbSegments(thread);\r\n        if (fromSegmentNumber < threadLength) {\r\n            const threadPart = thread.slice(fromSegmentNumber);\r\n            callback(threadPart, color);\r\n        }\r\n    }\r\n}\r\n\r\nexport {\r\n    IThreadToGrow,\r\n    ThreadBase,\r\n    ThreadsIterator,\r\n};\r\n","import { EColor } from \"../../plotter/compositing\";\r\nimport { IPeg } from \"../thread-computer\";\r\n\r\nimport { IThreadToGrow, ThreadBase, ThreadsIterator } from \"./thread-base\";\r\n\r\nclass ThreadMonochrome extends ThreadBase {\r\n    private threadPegs: IPeg[] = [];\r\n\r\n    public get totalNbSegments(): number {\r\n        return ThreadBase.computeNbSegments(this.threadPegs);\r\n    }\r\n\r\n    public lowerNbSegments(targetNumber: number): void {\r\n        ThreadBase.lowerNbSegmentsForThread(this.threadPegs, targetNumber);\r\n    }\r\n\r\n    public iterateOnThreads(nbSegmentsToIgnore: number, callback: ThreadsIterator): void {\r\n        ThreadBase.iterateOnThread(this.threadPegs, EColor.MONOCHROME, nbSegmentsToIgnore, callback);\r\n    }\r\n\r\n    public getThreadToGrow(): IThreadToGrow {\r\n        return {\r\n            thread: this.threadPegs,\r\n            color: EColor.MONOCHROME,\r\n        }\r\n    }\r\n\r\n    public adjustCanvasData(data: Uint8ClampedArray, blackBackground: boolean): void {\r\n        let computeAdjustedValue: (rawValue: number) => number;\r\n        if (blackBackground) {\r\n            computeAdjustedValue = (rawValue: number) => (255 - rawValue) / 2;\r\n        } else {\r\n            computeAdjustedValue = (rawValue: number) => rawValue / 2;\r\n        }\r\n\r\n        const nbPixels = data.length / 4;\r\n        for (let i = 0; i < nbPixels; i++) {\r\n            const averageSourceValue = (data[4 * i + 0] + data[4 * i + 1] + data[4 * i + 2]) / 3;\r\n            const adjustedValue = computeAdjustedValue(averageSourceValue);\r\n            data[4 * i + 0] = adjustedValue;\r\n            data[4 * i + 1] = adjustedValue;\r\n            data[4 * i + 2] = adjustedValue;\r\n        }\r\n    }\r\n\r\n    public enableSamplingFor(): void {\r\n        if (this.sampleCanvas === null) {\r\n            this.sampleCanvas = (data: Uint8ClampedArray, index: number) => {\r\n                return data[index + 0]; // only check the red channel because the hidden canvas is in black and white\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport { ThreadMonochrome };\r\n","import { EColor } from \"../../plotter/compositing\";\r\nimport { IPeg } from \"../thread-computer\";\r\n\r\nimport { IThreadToGrow, ThreadBase, ThreadsIterator } from \"./thread-base\";\r\n\r\ninterface ISegmentsRepartition {\r\n    red: number;\r\n    green: number;\r\n    blue: number;\r\n}\r\n\r\nclass ThreadRedBlueGreen extends ThreadBase {\r\n    private threadPegsRed: IPeg[] = [];\r\n    private threadPegsGreen: IPeg[] = [];\r\n    private threadPegsBlue: IPeg[] = [];\r\n\r\n    // indicators describing the colors repartition from the source image\r\n    private frequencyRed: number;\r\n    private frequencyGreen: number;\r\n    private frequencyBlue: number;\r\n\r\n    public get totalNbSegments(): number {\r\n        return ThreadBase.computeNbSegments(this.threadPegsRed) +\r\n            ThreadBase.computeNbSegments(this.threadPegsGreen) +\r\n            ThreadBase.computeNbSegments(this.threadPegsBlue);\r\n    }\r\n\r\n    public lowerNbSegments(targetNumber: number): void {\r\n        const repartition = this.computeIdealSegmentsRepartition(targetNumber);\r\n\r\n        ThreadBase.lowerNbSegmentsForThread(this.threadPegsRed, repartition.red);\r\n        ThreadBase.lowerNbSegmentsForThread(this.threadPegsGreen, repartition.green);\r\n        ThreadBase.lowerNbSegmentsForThread(this.threadPegsBlue, repartition.blue);\r\n    }\r\n\r\n    public iterateOnThreads(nbSegmentsToIgnore: number, callback: ThreadsIterator): void {\r\n        const repartition = this.computeIdealSegmentsRepartition(nbSegmentsToIgnore);\r\n\r\n        ThreadBase.iterateOnThread(this.threadPegsRed, EColor.RED, repartition.red, callback);\r\n        ThreadBase.iterateOnThread(this.threadPegsGreen, EColor.GREEN, repartition.green, callback);\r\n        ThreadBase.iterateOnThread(this.threadPegsBlue, EColor.BLUE, repartition.blue, callback);\r\n    }\r\n\r\n    public getThreadToGrow(): IThreadToGrow {\r\n        const repartition = this.computeIdealSegmentsRepartition(this.totalNbSegments + 1);\r\n        if (repartition.red > 0 && this.threadPegsRed.length < repartition.red + 1) {\r\n            return {\r\n                thread: this.threadPegsRed,\r\n                color: EColor.RED,\r\n            };\r\n        } else if (repartition.green > 0 && this.threadPegsGreen.length < repartition.green + 1) {\r\n            return {\r\n                thread: this.threadPegsGreen,\r\n                color: EColor.GREEN,\r\n            };\r\n        }\r\n\r\n        return {\r\n            thread: this.threadPegsBlue,\r\n            color: EColor.BLUE,\r\n        };\r\n    }\r\n\r\n    public adjustCanvasData(data: Uint8ClampedArray, blackBackground: boolean): void {\r\n        let cumulatedRed = 0;\r\n        let cumulatedGreen = 0;\r\n        let cumulatedBlue = 0;\r\n\r\n        let computeAdjustedValue: (rawValue: number) => number;\r\n        if (blackBackground) {\r\n            computeAdjustedValue = (rawValue: number) => (255 - rawValue) / 2;\r\n        } else {\r\n            computeAdjustedValue = (rawValue: number) => rawValue / 2;\r\n        }\r\n\r\n        const nbPixels = data.length / 4;\r\n        for (let i = 0; i < nbPixels; i++) {\r\n            cumulatedRed += data[4 * i + 0];\r\n            cumulatedGreen += data[4 * i + 1];\r\n            cumulatedBlue += data[4 * i + 2];\r\n\r\n            data[4 * i + 0] = computeAdjustedValue(data[4 * i + 0]);\r\n            data[4 * i + 1] = computeAdjustedValue(data[4 * i + 1]);\r\n            data[4 * i + 2] = computeAdjustedValue(data[4 * i + 2]);\r\n        }\r\n\r\n        if (!blackBackground) {\r\n            cumulatedRed = 255 * nbPixels - cumulatedRed;\r\n            cumulatedGreen = 255 * nbPixels - cumulatedGreen;\r\n            cumulatedBlue = 255 * nbPixels - cumulatedBlue;\r\n        }\r\n\r\n        const totalColor = cumulatedRed + cumulatedGreen + cumulatedBlue;\r\n        this.frequencyRed = cumulatedRed / totalColor;\r\n        this.frequencyGreen = cumulatedGreen / totalColor;\r\n        this.frequencyBlue = cumulatedBlue / totalColor;\r\n    }\r\n\r\n    public enableSamplingFor(color: EColor): void {\r\n        let channel: number;\r\n        if (color === EColor.RED) {\r\n            channel = 0;\r\n        } else if (color === EColor.GREEN) {\r\n            channel = 1;\r\n        } else {\r\n            channel = 2;\r\n        }\r\n\r\n        this.sampleCanvas = (data: Uint8ClampedArray, index: number) => {\r\n            return data[index + channel];\r\n        }\r\n    }\r\n\r\n    private computeIdealSegmentsRepartition(totalNbSegments: number): ISegmentsRepartition {\r\n        const idealRed = totalNbSegments * this.frequencyRed;\r\n        const idealGreen = totalNbSegments * this.frequencyGreen;\r\n        const idealBlue = totalNbSegments * this.frequencyBlue;\r\n\r\n        const repartition = {\r\n            red: Math.floor(idealRed),\r\n            green: Math.floor(idealGreen),\r\n            blue: Math.floor(idealBlue),\r\n        };\r\n\r\n        while (repartition.red + repartition.green + repartition.blue < totalNbSegments) {\r\n            const currentFrequencyRed = repartition.red / Math.max(1, repartition.red + repartition.green + repartition.blue);\r\n            const currentFrequencyGreen = repartition.green / Math.max(1, repartition.red + repartition.green + repartition.blue);\r\n            const currentFrequencyBlue = repartition.blue / Math.max(1, repartition.red + repartition.green + repartition.blue);\r\n\r\n            const gapRed = idealRed - currentFrequencyRed;\r\n            const gapGreen = idealGreen - currentFrequencyGreen;\r\n            const gapBlue = idealBlue - currentFrequencyBlue;\r\n\r\n            if (gapRed > gapGreen && gapRed > gapBlue) {\r\n                repartition.red++;\r\n            } else if (gapGreen > gapRed && gapGreen > gapBlue) {\r\n                repartition.green++;\r\n            } else {\r\n                repartition.blue++;\r\n            }\r\n        }\r\n\r\n        return repartition;\r\n    }\r\n}\r\n\r\nexport { ThreadRedBlueGreen };\r\n","import { IPoint } from \"../interfaces/i-point\";\r\nimport { ISize } from \"../interfaces/i-size\";\r\n\r\nclass Transformation {\r\n    public readonly scaling: number;\r\n    public readonly origin: IPoint;\r\n\r\n    public constructor(frameSize: ISize, elementSize: ISize) {\r\n        const scaleToFitWidth = frameSize.width / elementSize.width;\r\n        const scaleToFitHeight = frameSize.height / elementSize.height;\r\n\r\n        this.scaling = Math.min(scaleToFitWidth, scaleToFitHeight);\r\n        this.origin = {\r\n            x: 0.5 * (frameSize.width - this.scaling * elementSize.width),\r\n            y: 0.5 * (frameSize.height - this.scaling * elementSize.height)\r\n        };\r\n    }\r\n\r\n    public transform(point: IPoint): IPoint {\r\n        return {\r\n            x: this.origin.x + point.x * this.scaling,\r\n            y: this.origin.y + point.y * this.scaling,\r\n        };\r\n    }\r\n}\r\n\r\nexport { Transformation };\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(633);\n"],"sourceRoot":""}