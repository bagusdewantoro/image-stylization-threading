/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ts/helpers.ts":
/*!***************************!*\
  !*** ./src/ts/helpers.ts ***!
  \***************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export downloadTextFile [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getQueryStringValue [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getQueryStringValue = exports.downloadTextFile = void 0;
function downloadTextFile(content, filename) {
    var fileType = "text/plain";
    var blob = new Blob([content], { type: fileType });
    if (typeof window.navigator !== "undefined" && typeof window.navigator.msSaveBlob !== "undefined") {
        window.navigator.msSaveBlob(blob, filename);
    }
    else {
        var objectUrl_1 = URL.createObjectURL(blob);
        var linkElement = document.createElement('a');
        linkElement.download = filename;
        linkElement.href = objectUrl_1;
        linkElement.dataset.downloadurl = fileType + ":" + linkElement.download + ":" + linkElement.href;
        linkElement.style.display = "none";
        document.body.appendChild(linkElement);
        linkElement.click();
        document.body.removeChild(linkElement);
        setTimeout(function () {
            URL.revokeObjectURL(objectUrl_1);
        }, 5000);
    }
}
exports.downloadTextFile = downloadTextFile;
function getQueryStringValue(name) {
    var url = window.location.href;
    var queryStringStart = url.indexOf("?");
    if (queryStringStart >= 0) {
        var queryString = url.substring(queryStringStart + 1);
        if (queryString.length > 0) {
            var parameters = queryString.split("&");
            for (var _i = 0, parameters_1 = parameters; _i < parameters_1.length; _i++) {
                var parameter = parameters_1[_i];
                var keyValue = parameter.split("=");
                if (keyValue.length === 2) {
                    var decodedKey = decodeURIComponent(keyValue[0]);
                    if (decodedKey === name) {
                        return decodeURIComponent(keyValue[1]);
                    }
                }
            }
        }
    }
    return null;
}
exports.getQueryStringValue = getQueryStringValue;


/***/ }),

/***/ "./src/ts/main.ts":
/*!************************!*\
  !*** ./src/ts/main.ts ***!
  \************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 2:23-27 */
/*! CommonJS bailout: this is used directly at 9:26-30 */
/*! CommonJS bailout: this is used directly at 14:20-24 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Helpers = __importStar(__webpack_require__(/*! ./helpers */ "./src/ts/helpers.ts"));
var parameters_1 = __webpack_require__(/*! ./parameters */ "./src/ts/parameters.ts");
var plotter_canvas_2d_1 = __webpack_require__(/*! ./plotter/plotter-canvas-2d */ "./src/ts/plotter/plotter-canvas-2d.ts");
var plotter_svg_1 = __webpack_require__(/*! ./plotter/plotter-svg */ "./src/ts/plotter/plotter-svg.ts");
var thread_computer_1 = __webpack_require__(/*! ./threading/thread-computer */ "./src/ts/threading/thread-computer.ts");
var thread_plotter_1 = __webpack_require__(/*! ./threading/thread-plotter */ "./src/ts/threading/thread-plotter.ts");
__webpack_require__(/*! ./page-interface-generated */ "./src/ts/page-interface-generated.ts");
var MAX_COMPUTING_TIME_PER_FRAME = 20;
function main() {
    var canvasPlotter = new plotter_canvas_2d_1.PlotterCanvas2D();
    var threadPlotter = null;
    var threadComputer = null;
    var needToReset = true;
    parameters_1.Parameters.addRedrawObserver(function () { threadPlotter === null || threadPlotter === void 0 ? void 0 : threadPlotter.reset(); });
    parameters_1.Parameters.addResetObserver(function () { needToReset = true; });
    var indicatorsNeedUpdate = true;
    function mainLoop() {
        if (threadComputer !== null && threadPlotter !== null) {
            if (needToReset) {
                threadComputer.reset(parameters_1.Parameters.linesOpacity, parameters_1.Parameters.linesThickness);
                threadPlotter.reset();
                needToReset = false;
            }
            var computedSomething = threadComputer.computeNextSegments(MAX_COMPUTING_TIME_PER_FRAME);
            indicatorsNeedUpdate = indicatorsNeedUpdate || computedSomething;
            if (indicatorsNeedUpdate && parameters_1.Parameters.showIndicators) {
                threadComputer.updateIndicators(Page.Canvas.setIndicatorText);
                indicatorsNeedUpdate = false;
            }
            threadPlotter.plot();
            if (parameters_1.Parameters.debug) {
                threadComputer.drawDebugView(canvasPlotter.context);
            }
        }
        requestAnimationFrame(mainLoop);
    }
    requestAnimationFrame(mainLoop);
    function updateBlur(blur) {
        canvasPlotter.blur = blur;
    }
    parameters_1.Parameters.addBlurChangeObserver(updateBlur);
    updateBlur(parameters_1.Parameters.blur);
    function onNewImage(image) {
        Page.Canvas.showLoader(false);
        threadComputer = new thread_computer_1.ThreadComputer(image);
        threadPlotter = new thread_plotter_1.ThreadPlotter(canvasPlotter, threadComputer);
        needToReset = true;
    }
    parameters_1.Parameters.addFileUploadObserver(onNewImage);
    Page.Canvas.showLoader(true);
    var defaultImage = new Image();
    defaultImage.addEventListener("load", function () {
        onNewImage(defaultImage);
    });
    defaultImage.src = "./resources/cat.jpg";
    parameters_1.Parameters.addDownloadObserver(function () {
        var svgPlotter = new plotter_svg_1.PlotterSVG();
        var plotter = new thread_plotter_1.ThreadPlotter(svgPlotter, threadComputer);
        plotter.plot();
        var svgString = svgPlotter.export();
        var filename = "image-as-threading.svg";
        Helpers.downloadTextFile(svgString, filename);
    });
}
main();


/***/ }),

/***/ "./src/ts/page-interface-generated.ts":
/*!********************************************!*\
  !*** ./src/ts/page-interface-generated.ts ***!
  \********************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements:  */
/***/ (function() {




/***/ }),

/***/ "./src/ts/parameters.ts":
/*!******************************!*\
  !*** ./src/ts/parameters.ts ***!
  \******************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 2:23-27 */
/*! CommonJS bailout: this is used directly at 9:26-30 */
/*! CommonJS bailout: this is used directly at 14:20-24 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EShape = exports.EMode = exports.Parameters = void 0;
var Helpers = __importStar(__webpack_require__(/*! ./helpers */ "./src/ts/helpers.ts"));
__webpack_require__(/*! ./page-interface-generated */ "./src/ts/page-interface-generated.ts");
var controlId = {
    UPLOAD_INPUT_IMAGE: "input-image-upload-button",
    SHAPE: "shape-tabs-id",
    PEGS_DENSITY: "pegs-range-id",
    NB_LINES: "lines-range-id",
    QUALITY: "quality-tabs-id",
    MODE: "thread-mode-tabs-id",
    LINES_OPACITY: "opacity-range-id",
    LINES_THICKNESS: "thickness-range-id",
    DISPLAY_PEGS: "display-pegs-checkbox-id",
    INVERT_COLORS: "invert-colors-checkbox-id",
    SHOW_INDICATORS: "show-indicators-checkbox-id",
    BLUR: "blur-range-id",
    DOWNLOAD: "result-download-id",
};
var EShape;
(function (EShape) {
    EShape["RECTANGLE"] = "0";
    EShape["ELLIPSIS"] = "1";
})(EShape || (EShape = {}));
exports.EShape = EShape;
var EMode;
(function (EMode) {
    EMode["MONOCHROME"] = "0";
    EMode["COLORS"] = "1";
})(EMode || (EMode = {}));
exports.EMode = EMode;
var redrawObservers = [];
function triggerRedraw() {
    for (var _i = 0, redrawObservers_1 = redrawObservers; _i < redrawObservers_1.length; _i++) {
        var observer = redrawObservers_1[_i];
        observer();
    }
}
var resetObservers = [];
function triggerReset() {
    for (var _i = 0, resetObservers_1 = resetObservers; _i < resetObservers_1.length; _i++) {
        var observer = resetObservers_1[_i];
        observer();
    }
}
Page.Tabs.addObserver(controlId.SHAPE, triggerReset);
Page.Range.addLazyObserver(controlId.PEGS_DENSITY, triggerReset);
Page.Tabs.addObserver(controlId.QUALITY, triggerReset);
Page.Tabs.addObserver(controlId.MODE, triggerReset);
Page.Range.addLazyObserver(controlId.LINES_OPACITY, triggerReset);
Page.Range.addLazyObserver(controlId.LINES_THICKNESS, triggerReset);
Page.Checkbox.addObserver(controlId.DISPLAY_PEGS, triggerRedraw);
Page.Checkbox.addObserver(controlId.INVERT_COLORS, triggerReset);
Page.Canvas.Observers.canvasResize.push(triggerRedraw);
var isInDebug = Helpers.getQueryStringValue("debug") === "1";
Page.Canvas.setIndicatorVisibility("error-average", isInDebug);
Page.Canvas.setIndicatorVisibility("error-mean-square", isInDebug);
Page.Canvas.setIndicatorVisibility("error-variance", isInDebug);
function updateIndicatorsVisibility() {
    var shouldBeVisible = Page.Checkbox.isChecked(controlId.SHOW_INDICATORS);
    Page.Canvas.setIndicatorsVisibility(shouldBeVisible);
}
Page.Checkbox.addObserver(controlId.SHOW_INDICATORS, updateIndicatorsVisibility);
updateIndicatorsVisibility();
var Parameters = (function () {
    function Parameters() {
    }
    Parameters.addFileUploadObserver = function (callback) {
        Page.FileControl.addUploadObserver(controlId.UPLOAD_INPUT_IMAGE, function (filesList) {
            if (filesList.length === 1) {
                Page.Canvas.showLoader(true);
                var reader_1 = new FileReader();
                reader_1.onload = function () {
                    var image = new Image();
                    image.addEventListener("load", function () {
                        callback(image);
                    });
                    image.src = reader_1.result;
                };
                reader_1.readAsDataURL(filesList[0]);
            }
        });
    };
    Object.defineProperty(Parameters, "debug", {
        get: function () {
            return isInDebug;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "shape", {
        get: function () {
            return Page.Tabs.getValues(controlId.SHAPE)[0];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "pegsSpacing", {
        get: function () {
            return 1.1 - Page.Range.getValue(controlId.PEGS_DENSITY);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "quality", {
        get: function () {
            return +Page.Tabs.getValues(controlId.QUALITY)[0];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "mode", {
        get: function () {
            return Page.Tabs.getValues(controlId.MODE)[0];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "nbLines", {
        get: function () {
            return Page.Range.getValue(controlId.NB_LINES);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "linesOpacity", {
        get: function () {
            var raw = Page.Range.getValue(controlId.LINES_OPACITY);
            return Math.pow(2, raw - 7);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "linesThickness", {
        get: function () {
            return Page.Range.getValue(controlId.LINES_THICKNESS);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "displayPegs", {
        get: function () {
            return Page.Checkbox.isChecked(controlId.DISPLAY_PEGS);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "invertColors", {
        get: function () {
            return Page.Checkbox.isChecked(controlId.INVERT_COLORS);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "showIndicators", {
        get: function () {
            return Page.Checkbox.isChecked(controlId.SHOW_INDICATORS);
        },
        enumerable: false,
        configurable: true
    });
    Parameters.addRedrawObserver = function (callback) {
        redrawObservers.push(callback);
    };
    Parameters.addResetObserver = function (callback) {
        resetObservers.push(callback);
    };
    Object.defineProperty(Parameters, "blur", {
        get: function () {
            return Page.Range.getValue(controlId.BLUR);
        },
        enumerable: false,
        configurable: true
    });
    Parameters.addBlurChangeObserver = function (callback) {
        Page.Range.addObserver(controlId.BLUR, callback);
    };
    Parameters.addDownloadObserver = function (callback) {
        Page.FileControl.addDownloadObserver(controlId.DOWNLOAD, callback);
    };
    return Parameters;
}());
exports.Parameters = Parameters;


/***/ }),

/***/ "./src/ts/plotter/compositing.ts":
/*!***************************************!*\
  !*** ./src/ts/plotter/compositing.ts ***!
  \***************************************/
/*! flagged exports */
/*! export EColor [provided] [no usage info] [missing usage info prevents renaming] */
/*! export ECompositingOperation [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export applyCanvasCompositing [provided] [no usage info] [missing usage info prevents renaming] */
/*! export computeRawColor [provided] [no usage info] [missing usage info prevents renaming] */
/*! export resetCanvasCompositing [provided] [no usage info] [missing usage info prevents renaming] */
/*! export useAdvancedCompositing [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useAdvancedCompositing = exports.resetCanvasCompositing = exports.computeRawColor = exports.applyCanvasCompositing = exports.ECompositingOperation = exports.EColor = void 0;
var ECompositingOperation;
(function (ECompositingOperation) {
    ECompositingOperation[ECompositingOperation["DARKEN"] = 0] = "DARKEN";
    ECompositingOperation[ECompositingOperation["LIGHTEN"] = 1] = "LIGHTEN";
})(ECompositingOperation || (ECompositingOperation = {}));
exports.ECompositingOperation = ECompositingOperation;
var EColor;
(function (EColor) {
    EColor[EColor["MONOCHROME"] = 0] = "MONOCHROME";
    EColor[EColor["RED"] = 1] = "RED";
    EColor[EColor["GREEN"] = 2] = "GREEN";
    EColor[EColor["BLUE"] = 3] = "BLUE";
})(EColor || (EColor = {}));
exports.EColor = EColor;
var supportsAdvancedCompositing = true;
function useAdvancedCompositing() {
    return supportsAdvancedCompositing;
}
exports.useAdvancedCompositing = useAdvancedCompositing;
function computeRawColor(color) {
    if (color === EColor.MONOCHROME) {
        return { r: 1, g: 1, b: 1 };
    }
    var result = {
        r: (color === EColor.RED) ? 1 : 0,
        g: (color === EColor.GREEN) ? 1 : 0,
        b: (color === EColor.BLUE) ? 1 : 0,
    };
    return result;
}
exports.computeRawColor = computeRawColor;
function applyCanvasCompositing(context, color, opacity, operation) {
    if (supportsAdvancedCompositing) {
        var targetOperation = (operation === ECompositingOperation.LIGHTEN) ? "lighter" : "difference";
        context.globalCompositeOperation = targetOperation;
        if (context.globalCompositeOperation === targetOperation) {
            var value = Math.ceil(255 * opacity);
            var rawRGB = computeRawColor(color);
            context.strokeStyle = "rgb(" + rawRGB.r * value + ", " + rawRGB.g * value + ", " + rawRGB.b * value + ")";
            return;
        }
        else {
            supportsAdvancedCompositing = false;
            Page.Demopage.setErrorMessage("advanced-compositing-not-supported", "Your browser does not support canvas2D compositing '" + targetOperation + "'. The project will not run as expected.");
        }
    }
    {
        resetCanvasCompositing(context);
        var value = (operation === ECompositingOperation.LIGHTEN) ? 255 : 0;
        var rawRGB = computeRawColor(color);
        context.strokeStyle = "rgba(" + rawRGB.r * value + ", " + rawRGB.g * value + ", " + rawRGB.b * value + ", " + opacity + ")";
    }
}
exports.applyCanvasCompositing = applyCanvasCompositing;
function resetCanvasCompositing(context) {
    context.globalCompositeOperation = "source-over";
}
exports.resetCanvasCompositing = resetCanvasCompositing;


/***/ }),

/***/ "./src/ts/plotter/plotter-base.ts":
/*!****************************************!*\
  !*** ./src/ts/plotter/plotter-base.ts ***!
  \****************************************/
/*! flagged exports */
/*! export PlotterBase [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlotterBase = void 0;
;
var PlotterBase = (function () {
    function PlotterBase() {
    }
    PlotterBase.prototype.drawBrokenLine = function (points, color, opacity, operation, thickness) {
        var lines = [];
        for (var i = 0; i < points.length - 1; i++) {
            lines.push({ from: points[i], to: points[i + 1] });
        }
        this.drawLines(lines, color, opacity, operation, thickness);
    };
    return PlotterBase;
}());
exports.PlotterBase = PlotterBase;


/***/ }),

/***/ "./src/ts/plotter/plotter-canvas-2d.ts":
/*!*********************************************!*\
  !*** ./src/ts/plotter/plotter-canvas-2d.ts ***!
  \*********************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 2:17-21 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlotterCanvas2D = void 0;
var plotter_base_1 = __webpack_require__(/*! ./plotter-base */ "./src/ts/plotter/plotter-base.ts");
__webpack_require__(/*! ../page-interface-generated */ "./src/ts/page-interface-generated.ts");
var compositing_1 = __webpack_require__(/*! ./compositing */ "./src/ts/plotter/compositing.ts");
var PlotterCanvas2D = (function (_super) {
    __extends(PlotterCanvas2D, _super);
    function PlotterCanvas2D() {
        var _a;
        var _this = _super.call(this) || this;
        _this.canvas = Page.Canvas.getCanvas();
        _this.context = _this.canvas.getContext("2d", { alpha: false });
        _this.cssPixel = (_a = window.devicePixelRatio) !== null && _a !== void 0 ? _a : 1;
        return _this;
    }
    PlotterCanvas2D.prototype.resize = function () {
        var actualWidth = Math.floor(this.cssPixel * this.canvas.clientWidth);
        var actualHeight = Math.floor(this.cssPixel * this.canvas.clientHeight);
        if (this.canvas.width !== actualWidth || this.canvas.height !== actualHeight) {
            this.canvas.width = actualWidth;
            this.canvas.height = actualHeight;
        }
    };
    PlotterCanvas2D.prototype.initialize = function (infos) {
        this.context.fillStyle = infos.backgroundColor;
        this.context.lineJoin = "round";
        compositing_1.resetCanvasCompositing(this.context);
        this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
    };
    PlotterCanvas2D.prototype.finalize = function () { };
    Object.defineProperty(PlotterCanvas2D.prototype, "blur", {
        set: function (value) {
            if (value === 0) {
                this.canvas.style.filter = "";
            }
            else {
                this.canvas.style.filter = "blur(" + value + "px)";
                this.canvas.style.filter = "url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='a' x='0' y='0' width='1' height='1'%3E%3CfeGaussianBlur stdDeviation='" + value + "' result='b'/%3E%3CfeMorphology operator='dilate' radius='" + value + "'/%3E %3CfeMerge%3E%3CfeMergeNode/%3E%3CfeMergeNode in='b'/%3E%3C/feMerge%3E%3C/filter%3E%3C/svg%3E#a\")";
            }
        },
        enumerable: false,
        configurable: true
    });
    PlotterCanvas2D.prototype.drawLines = function (lines, color, opacity, operation, thickness) {
        if (lines.length >= 1) {
            compositing_1.applyCanvasCompositing(this.context, color, opacity, operation);
            this.context.lineWidth = thickness * this.cssPixel;
            for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
                var line = lines_1[_i];
                this.context.beginPath();
                this.context.moveTo(line.from.x * this.cssPixel, line.from.y * this.cssPixel);
                this.context.lineTo(line.to.x * this.cssPixel, line.to.y * this.cssPixel);
                this.context.stroke();
                this.context.closePath();
            }
            compositing_1.resetCanvasCompositing(this.context);
        }
    };
    PlotterCanvas2D.prototype.drawPoints = function (points, color, diameter) {
        if (points.length > 0) {
            this.context.fillStyle = color;
            this.context.strokeStyle = "none";
            for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
                var point = points_1[_i];
                this.context.beginPath();
                this.context.arc(point.x * this.cssPixel, point.y * this.cssPixel, 0.5 * diameter * this.cssPixel, 0, 2 * Math.PI);
                this.context.fill();
                this.context.closePath();
            }
        }
    };
    Object.defineProperty(PlotterCanvas2D.prototype, "size", {
        get: function () {
            return {
                width: Math.floor(this.canvas.width / this.cssPixel),
                height: Math.floor(this.canvas.height / this.cssPixel),
            };
        },
        enumerable: false,
        configurable: true
    });
    return PlotterCanvas2D;
}(plotter_base_1.PlotterBase));
exports.PlotterCanvas2D = PlotterCanvas2D;


/***/ }),

/***/ "./src/ts/plotter/plotter-svg.ts":
/*!***************************************!*\
  !*** ./src/ts/plotter/plotter-svg.ts ***!
  \***************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 2:17-21 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlotterSVG = void 0;
var compositing_1 = __webpack_require__(/*! ./compositing */ "./src/ts/plotter/compositing.ts");
var plotter_base_1 = __webpack_require__(/*! ./plotter-base */ "./src/ts/plotter/plotter-base.ts");
var xml_writer_1 = __webpack_require__(/*! ./xml-writer */ "./src/ts/plotter/xml-writer.ts");
var WIDTH = 1000;
var HEIGHT = 1000;
var BLUR_EFFECT_ID = "gaussianBlur";
var PlotterSVG = (function (_super) {
    __extends(PlotterSVG, _super);
    function PlotterSVG() {
        return _super.call(this) || this;
    }
    PlotterSVG.prototype.resize = function () {
    };
    PlotterSVG.prototype.initialize = function (infos) {
        this.writer = new xml_writer_1.XMLWriter();
        this.hasBlur = infos.blur > 0;
        this.writer.addLine("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>");
        this.writer.startBlock("<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" viewBox=\"0 0 " + WIDTH + " " + HEIGHT + "\">");
        if (this.hasBlur) {
            this.writer.startBlock("<defs>");
            this.writer.startBlock("<filter id=\"" + BLUR_EFFECT_ID + "\" x=\"0\" y=\"0\">");
            this.writer.addLine("<feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"" + infos.blur + "\"/>");
            this.writer.endBlock("</filter>");
            this.writer.endBlock("</defs>");
            this.writer.startBlock("<g filter=\"url(#" + BLUR_EFFECT_ID + ")\">");
        }
        var margin = 10;
        this.writer.addLine("<rect fill=\"white\" stroke=\"none\" x=\"" + -margin + "\" y=\"" + -margin + "\" width=\"" + (WIDTH + 2 * margin) + "\" height=\"" + (HEIGHT + 2 * margin) + "\"/>");
    };
    PlotterSVG.prototype.finalize = function () {
        if (this.hasBlur) {
            this.writer.endBlock("</g>");
        }
        this.writer.endBlock("</svg>");
    };
    PlotterSVG.prototype.drawLines = function (lines, color, opacity, operation, thickness) {
        if (lines.length >= 1) {
            var strokeColor = void 0;
            if (compositing_1.useAdvancedCompositing()) {
                this.writer.startBlock("<defs>");
                this.writer.startBlock("<style type=\"text/css\">");
                this.writer.startBlock("<![CDATA[");
                this.writer.addLine("line { mix-blend-mode: difference; }");
                if (operation === compositing_1.ECompositingOperation.LIGHTEN) {
                    this.writer.addLine("svg { filter: invert(1); background: black; }");
                }
                this.writer.endBlock("]]>");
                this.writer.endBlock("</style>");
                this.writer.endBlock("</defs>");
                var value = Math.ceil(255 * opacity);
                var rawRGB = compositing_1.computeRawColor(color);
                strokeColor = "rgb(" + rawRGB.r * value + ", " + rawRGB.g * value + ", " + rawRGB.b * value + ")";
            }
            else {
                var value = (compositing_1.useAdvancedCompositing()) ? 255 : 0;
                var rawRGB = compositing_1.computeRawColor(color);
                strokeColor = "rgba(" + rawRGB.r * value + ", " + rawRGB.g * value + ", " + rawRGB.b * value + ", " + opacity + ")";
            }
            this.writer.startBlock("<g stroke=\"" + strokeColor + "\" stroke-width=\"" + thickness + "\" stroke-linecap=\"round\" fill=\"none\">");
            for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
                var line = lines_1[_i];
                this.writer.addLine("<line x1=\"" + line.from.x.toFixed(1) + "\" y1=\"" + line.from.y.toFixed(1) + "\" x2=\"" + line.to.x.toFixed(1) + "\" y2=\"" + line.to.y.toFixed(1) + "\"/>");
            }
            this.writer.endBlock("</g>");
        }
    };
    PlotterSVG.prototype.drawPoints = function (points, color, diameter) {
        if (points.length > 0) {
            this.writer.startBlock("<g fill=\"" + color + "\" stroke=\"none\">");
            for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
                var point = points_1[_i];
                this.writer.addLine("<circle cx=\"" + point.x.toFixed(1) + "\" cy=\"" + point.y.toFixed(1) + "\" r=\"" + 0.5 * diameter + "\"/>");
            }
            this.writer.endBlock("</g>");
        }
    };
    PlotterSVG.prototype.export = function () {
        var start = Date.now();
        var result = this.writer.result;
        console.log("Concatenation took " + (Date.now() - start) + " ms.");
        return result;
    };
    Object.defineProperty(PlotterSVG.prototype, "size", {
        get: function () {
            return {
                width: WIDTH,
                height: HEIGHT,
            };
        },
        enumerable: false,
        configurable: true
    });
    return PlotterSVG;
}(plotter_base_1.PlotterBase));
exports.PlotterSVG = PlotterSVG;


/***/ }),

/***/ "./src/ts/plotter/xml-writer.ts":
/*!**************************************!*\
  !*** ./src/ts/plotter/xml-writer.ts ***!
  \**************************************/
/*! flagged exports */
/*! export XMLWriter [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.XMLWriter = void 0;
var XMLWriter = (function () {
    function XMLWriter() {
        this.indentationLevel = 0;
        this.lines = [];
    }
    Object.defineProperty(XMLWriter.prototype, "result", {
        get: function () {
            return this.lines.join("\n");
        },
        enumerable: false,
        configurable: true
    });
    XMLWriter.prototype.startBlock = function (line) {
        this.addLine(line);
        this.indentationLevel++;
    };
    XMLWriter.prototype.endBlock = function (line) {
        this.indentationLevel--;
        this.addLine(line);
    };
    XMLWriter.prototype.addLine = function (line) {
        this.lines.push(this.prefix + line);
    };
    Object.defineProperty(XMLWriter.prototype, "prefix", {
        get: function () {
            return "\t".repeat(this.indentationLevel);
        },
        enumerable: false,
        configurable: true
    });
    return XMLWriter;
}());
exports.XMLWriter = XMLWriter;


/***/ }),

/***/ "./src/ts/threading/thread-computer.ts":
/*!*********************************************!*\
  !*** ./src/ts/threading/thread-computer.ts ***!
  \*********************************************/
/*! flagged exports */
/*! export ThreadComputer [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ThreadComputer = void 0;
var parameters_1 = __webpack_require__(/*! ../parameters */ "./src/ts/parameters.ts");
var transformation_1 = __webpack_require__(/*! ./transformation */ "./src/ts/threading/transformation.ts");
var compositing_1 = __webpack_require__(/*! ../plotter/compositing */ "./src/ts/plotter/compositing.ts");
var thread_monochrome_1 = __webpack_require__(/*! ./thread/thread-monochrome */ "./src/ts/threading/thread/thread-monochrome.ts");
var thread_red_green_blue_1 = __webpack_require__(/*! ./thread/thread-red-green-blue */ "./src/ts/threading/thread/thread-red-green-blue.ts");
var MIN_SAFE_NUMBER = -9007199254740991;
var TWO_PI = 2 * Math.PI;
function clamp(x, min, max) {
    if (x < min) {
        return min;
    }
    else if (x > max) {
        return max;
    }
    return x;
}
function mix(a, b, x) {
    return a * (1 - x) + b * x;
}
function distance(p1, p2) {
    var dX = p1.x - p2.x;
    var dY = p1.y - p2.y;
    return Math.sqrt(dX * dX + dY * dY);
}
function randomItem(list) {
    if (list.length === 0) {
        return null;
    }
    var randomIndex = Math.floor(Math.random() * list.length);
    return list[randomIndex];
}
var ThreadComputer = (function () {
    function ThreadComputer(image) {
        this.hiddenCanvasData = null;
        this.sourceImage = image;
        this.hiddenCanvas = document.createElement("canvas");
        this.hiddenCanvasContext = this.hiddenCanvas.getContext("2d");
        this.reset(16 / 256, 1);
    }
    ThreadComputer.prototype.drawThread = function (plotter, nbSegmentsToIgnore) {
        var _this = this;
        var transformation = this.computeTransformation(plotter.size);
        var lineWidth = (transformation.scaling * this.hiddenCanvasScale) * this.lineThickness;
        var compositing = parameters_1.Parameters.invertColors ? compositing_1.ECompositingOperation.LIGHTEN : compositing_1.ECompositingOperation.DARKEN;
        this.thread.iterateOnThreads(nbSegmentsToIgnore, function (thread, color) {
            var points = [];
            for (var _i = 0, thread_1 = thread; _i < thread_1.length; _i++) {
                var peg = thread_1[_i];
                points.push(transformation.transform(peg));
            }
            plotter.drawBrokenLine(points, color, _this.lineOpacity, compositing, lineWidth);
        });
    };
    ThreadComputer.prototype.drawPegs = function (plotter) {
        var transformation = this.computeTransformation(plotter.size);
        var pointSize = 0.5 * (transformation.scaling * this.hiddenCanvasScale);
        var points = [];
        for (var _i = 0, _a = this.pegs; _i < _a.length; _i++) {
            var peg = _a[_i];
            points.push(transformation.transform(peg));
        }
        plotter.drawPoints(points, "red", pointSize);
    };
    ThreadComputer.prototype.drawDebugView = function (targetContext) {
        targetContext.drawImage(this.hiddenCanvas, 0, 0, this.hiddenCanvas.width, this.hiddenCanvas.height);
    };
    ThreadComputer.prototype.computeNextSegments = function (maxMillisecondsTaken) {
        var _this = this;
        var start = performance.now();
        var targetNbSegments = parameters_1.Parameters.nbLines;
        if (this.nbSegments === targetNbSegments) {
            return false;
        }
        else if (this.nbSegments > targetNbSegments) {
            this.thread.lowerNbSegments(targetNbSegments);
            this.resetHiddenCanvas();
            this.thread.iterateOnThreads(0, function (thread, color) {
                compositing_1.applyCanvasCompositing(_this.hiddenCanvasContext, color, _this.lineOpacityInternal, compositing_1.ECompositingOperation.LIGHTEN);
                for (var iPeg = 0; iPeg + 1 < thread.length; iPeg++) {
                    _this.drawSegmentOnHiddenCanvas(thread[iPeg], thread[iPeg + 1]);
                }
            });
            this.computeError();
            return true;
        }
        var lastColor = null;
        while (this.nbSegments < targetNbSegments && performance.now() - start < maxMillisecondsTaken) {
            var threadToGrow = this.thread.getThreadToGrow();
            if (lastColor !== threadToGrow.color) {
                compositing_1.applyCanvasCompositing(this.hiddenCanvasContext, threadToGrow.color, this.lineOpacityInternal, compositing_1.ECompositingOperation.LIGHTEN);
                this.thread.enableSamplingFor(threadToGrow.color);
                lastColor = threadToGrow.color;
            }
            this.computeSegment(threadToGrow.thread);
            if (this.nbSegments % 100 === 0) {
                this.computeError();
            }
        }
        return true;
    };
    ThreadComputer.prototype.reset = function (opacity, linethickness) {
        this.lineOpacity = opacity;
        this.lineThickness = linethickness;
        this.hiddenCanvasScale = parameters_1.Parameters.quality;
        if (parameters_1.Parameters.mode === parameters_1.EMode.MONOCHROME) {
            this.thread = new thread_monochrome_1.ThreadMonochrome();
        }
        else {
            this.thread = new thread_red_green_blue_1.ThreadRedBlueGreen();
        }
        this.resetHiddenCanvas();
        this.pegs = this.computePegs();
    };
    ThreadComputer.prototype.updateIndicators = function (updateFunction) {
        updateFunction("pegs-count", this.pegs.length.toString());
        updateFunction("segments-count", this.nbSegments.toString());
        updateFunction("error-average", this.error.average.toString());
        updateFunction("error-mean-square", this.error.meanSquare.toString());
        updateFunction("error-variance", this.error.variance.toString());
    };
    Object.defineProperty(ThreadComputer.prototype, "nbSegments", {
        get: function () {
            return this.thread.totalNbSegments;
        },
        enumerable: false,
        configurable: true
    });
    ThreadComputer.prototype.initializeHiddenCanvasLineProperties = function () {
        var theoricalThicknes = this.lineThickness * this.hiddenCanvasScale;
        if (theoricalThicknes <= 1) {
            this.lineOpacityInternal = 0.5 * this.lineOpacity * theoricalThicknes;
            this.hiddenCanvasContext.lineWidth = 1;
        }
        else {
            this.lineOpacityInternal = 0.5 * this.lineOpacity;
            this.hiddenCanvasContext.lineWidth = theoricalThicknes;
        }
    };
    ThreadComputer.prototype.computeSegment = function (thread) {
        var lastPeg;
        var nextPeg;
        if (thread.length === 0) {
            var startingSegment = this.computeBestStartingSegment();
            thread.push(startingSegment.peg1);
            lastPeg = startingSegment.peg1;
            nextPeg = startingSegment.peg2;
        }
        else {
            lastPeg = thread[thread.length - 1];
            nextPeg = this.computeBestNextPeg(lastPeg);
        }
        thread.push(nextPeg);
        this.drawSegmentOnHiddenCanvas(lastPeg, nextPeg);
    };
    ThreadComputer.prototype.resetHiddenCanvas = function () {
        var wantedSize = ThreadComputer.computeBestSize(this.sourceImage, 100 * this.hiddenCanvasScale);
        this.hiddenCanvas.width = wantedSize.width;
        this.hiddenCanvas.height = wantedSize.height;
        compositing_1.resetCanvasCompositing(this.hiddenCanvasContext);
        this.hiddenCanvasContext.drawImage(this.sourceImage, 0, 0, wantedSize.width, wantedSize.height);
        var imageData = this.hiddenCanvasContext.getImageData(0, 0, wantedSize.width, wantedSize.height);
        this.thread.adjustCanvasData(imageData.data, parameters_1.Parameters.invertColors);
        this.hiddenCanvasContext.putImageData(imageData, 0, 0);
        this.computeError();
        this.initializeHiddenCanvasLineProperties();
    };
    ThreadComputer.prototype.computeError = function () {
        this.uploadCanvasDataToCPU();
        this.error = {
            average: 0,
            variance: 0,
            meanSquare: 0,
        };
        var nbPixels = this.hiddenCanvasData.width * this.hiddenCanvasData.height;
        var nbSamples = 3 * nbPixels;
        for (var iP = 0; iP < nbPixels; iP++) {
            var errorRed = 127 - this.hiddenCanvasData.data[4 * iP + 0];
            var errorGreen = 127 - this.hiddenCanvasData.data[4 * iP + 1];
            var errorBlue = 127 - this.hiddenCanvasData.data[4 * iP + 2];
            this.error.average += errorRed + errorGreen + errorBlue;
            this.error.meanSquare += (errorRed * errorRed) + (errorGreen * errorGreen) + (errorBlue * errorBlue);
        }
        this.error.average = Math.round(this.error.average / nbSamples);
        this.error.meanSquare = Math.round(this.error.meanSquare / nbSamples);
        for (var iP = 0; iP < nbPixels; iP++) {
            var errorRed = 127 - this.hiddenCanvasData.data[4 * iP + 0];
            var errorGreen = 127 - this.hiddenCanvasData.data[4 * iP + 1];
            var errorBlue = 127 - this.hiddenCanvasData.data[4 * iP + 2];
            var error = (errorRed + errorGreen + errorBlue) / 3;
            var distancetoError = error - this.error.average;
            this.error.variance += distancetoError * distancetoError;
        }
        this.error.variance = Math.round(this.error.variance / nbSamples);
    };
    ThreadComputer.prototype.computeTransformation = function (targetSize) {
        return new transformation_1.Transformation(targetSize, this.hiddenCanvas);
    };
    ThreadComputer.prototype.drawSegmentOnHiddenCanvas = function (peg1, peg2) {
        this.hiddenCanvasContext.beginPath();
        this.hiddenCanvasContext.moveTo(peg1.x, peg1.y);
        this.hiddenCanvasContext.lineTo(peg2.x, peg2.y);
        this.hiddenCanvasContext.stroke();
        this.hiddenCanvasContext.closePath();
        this.hiddenCanvasData = null;
    };
    ThreadComputer.prototype.computeBestStartingSegment = function () {
        var candidates = [];
        var bestScore = MIN_SAFE_NUMBER;
        var step = 1 + Math.floor(this.pegs.length / 100);
        for (var iPegId1 = 0; iPegId1 < this.pegs.length; iPegId1 += step) {
            for (var iPegId2 = iPegId1 + 1; iPegId2 < this.pegs.length; iPegId2 += step) {
                var peg1 = this.pegs[iPegId1];
                var peg2 = this.pegs[iPegId2];
                if (!this.arePegsTooClose(peg1, peg2)) {
                    var candidateScore = this.computeSegmentPotential(peg1, peg2);
                    if (candidateScore > bestScore) {
                        bestScore = candidateScore;
                        candidates = [{ peg1: peg1, peg2: peg2, }];
                    }
                    else if (candidateScore === bestScore) {
                        candidates.push({ peg1: peg1, peg2: peg2, });
                    }
                }
            }
        }
        return randomItem(candidates);
    };
    ThreadComputer.prototype.computeBestNextPeg = function (currentPeg) {
        var candidates = [];
        var bestScore = MIN_SAFE_NUMBER;
        for (var _i = 0, _a = this.pegs; _i < _a.length; _i++) {
            var peg = _a[_i];
            if (!this.arePegsTooClose(currentPeg, peg)) {
                var candidateScore = this.computeSegmentPotential(currentPeg, peg);
                if (candidateScore > bestScore) {
                    bestScore = candidateScore;
                    candidates = [peg];
                }
                else if (candidateScore === bestScore) {
                    candidates.push(peg);
                }
            }
        }
        return randomItem(candidates);
    };
    ThreadComputer.prototype.uploadCanvasDataToCPU = function () {
        if (this.hiddenCanvasData === null) {
            var width = this.hiddenCanvas.width;
            var height = this.hiddenCanvas.height;
            this.hiddenCanvasData = this.hiddenCanvasContext.getImageData(0, 0, width, height);
        }
    };
    ThreadComputer.prototype.computeSegmentPotential = function (peg1, peg2) {
        this.uploadCanvasDataToCPU();
        var potential = 0;
        var segmentLength = distance(peg1, peg2);
        var nbSamples = Math.ceil(segmentLength);
        for (var iSample = 0; iSample < nbSamples; iSample++) {
            var r = (iSample + 1) / (nbSamples + 1);
            var sample = {
                x: mix(peg1.x, peg2.x, r),
                y: mix(peg1.y, peg2.y, r),
            };
            var imageValue = this.sampleCanvasData(sample);
            var finalValue = imageValue + (this.lineOpacityInternal * 255);
            var contribution = 127 - finalValue;
            potential += contribution;
        }
        return potential / nbSamples;
    };
    ThreadComputer.prototype.sampleCanvasData = function (coords) {
        var width = this.hiddenCanvasData.width;
        var height = this.hiddenCanvasData.height;
        var minX = clamp(Math.floor(coords.x), 0, width - 1);
        var maxX = clamp(Math.ceil(coords.x), 0, width - 1);
        var minY = clamp(Math.floor(coords.y), 0, height - 1);
        var maxY = clamp(Math.ceil(coords.y), 0, height - 1);
        var topLeft = this.sampleCanvasPixel(minX, minY);
        var topRight = this.sampleCanvasPixel(maxX, minY);
        var bottomLeft = this.sampleCanvasPixel(minX, maxY);
        var bottomRight = this.sampleCanvasPixel(maxX, maxY);
        var fractX = coords.x % 1;
        var top = mix(topLeft, topRight, fractX);
        var bottom = mix(bottomLeft, bottomRight, fractX);
        var fractY = coords.y % 1;
        return mix(top, bottom, fractY);
    };
    ThreadComputer.prototype.sampleCanvasPixel = function (pixelX, pixelY) {
        var index = 4 * (pixelX + pixelY * this.hiddenCanvasData.width);
        return this.thread.sampleCanvas(this.hiddenCanvasData.data, index);
    };
    ThreadComputer.computeBestSize = function (sourceImageSize, maxSize) {
        var maxSourceSide = Math.max(sourceImageSize.width, sourceImageSize.height);
        var sizingFactor = maxSize / maxSourceSide;
        return {
            width: Math.ceil(sourceImageSize.width * sizingFactor),
            height: Math.ceil(sourceImageSize.height * sizingFactor),
        };
    };
    ThreadComputer.prototype.computePegs = function () {
        var domainSize;
        {
            var DEFAULT_CANVAS_SIZE_FOR_PEGS = 1000;
            var aspectRatio = this.hiddenCanvas.width / this.hiddenCanvas.height;
            if (aspectRatio > 1) {
                domainSize = { width: DEFAULT_CANVAS_SIZE_FOR_PEGS, height: Math.round(DEFAULT_CANVAS_SIZE_FOR_PEGS / aspectRatio) };
            }
            else {
                domainSize = { width: Math.round(DEFAULT_CANVAS_SIZE_FOR_PEGS * aspectRatio), height: DEFAULT_CANVAS_SIZE_FOR_PEGS };
            }
        }
        var pegsShape = parameters_1.Parameters.shape;
        var pegsSpacing = 20 * parameters_1.Parameters.pegsSpacing;
        var pegs = [];
        if (pegsShape === parameters_1.EShape.RECTANGLE) {
            this.arePegsTooClose = function (peg1, peg2) {
                return peg1.x === peg2.x || peg1.y === peg2.y;
            };
            var maxX = domainSize.width;
            var maxY = domainSize.height;
            pegs.push({ x: 0, y: 0 });
            pegs.push({ x: maxX, y: 0 });
            pegs.push({ x: maxX, y: maxY });
            pegs.push({ x: 0, y: maxY });
            var nbPegsPerWidth = Math.ceil(domainSize.width / pegsSpacing);
            for (var iW = 1; iW < nbPegsPerWidth; iW++) {
                var x = maxX * (iW / nbPegsPerWidth);
                pegs.push({ x: x, y: 0 });
                pegs.push({ x: x, y: maxY });
            }
            var nbPegsPerHeight = Math.ceil(domainSize.height / pegsSpacing);
            for (var iH = 1; iH < nbPegsPerHeight; iH++) {
                var y = maxY * (iH / nbPegsPerHeight);
                pegs.push({ x: 0, y: y });
                pegs.push({ x: maxX, y: y });
            }
        }
        else {
            this.arePegsTooClose = function (peg1, peg2) {
                var absDeltaAngle = Math.abs(peg1.angle - peg2.angle);
                var minAngle = Math.min(absDeltaAngle, TWO_PI - absDeltaAngle);
                return minAngle <= TWO_PI / 16;
            };
            var maxSize = Math.max(domainSize.width, domainSize.height);
            var nbPegs = Math.ceil(0.5 * TWO_PI * maxSize / pegsSpacing);
            var baseDeltaAngle = TWO_PI / nbPegs;
            for (var iPeg = 0; iPeg < nbPegs; iPeg++) {
                var angle = iPeg * baseDeltaAngle;
                var peg = {
                    x: 0.5 * domainSize.width * (1 + Math.cos(angle)),
                    y: 0.5 * domainSize.height * (1 + Math.sin(angle)),
                    angle: angle,
                };
                pegs.push(peg);
            }
        }
        for (var _i = 0, pegs_1 = pegs; _i < pegs_1.length; _i++) {
            var peg = pegs_1[_i];
            peg.x *= this.hiddenCanvas.width / domainSize.width;
            peg.y *= this.hiddenCanvas.height / domainSize.height;
        }
        return pegs;
    };
    return ThreadComputer;
}());
exports.ThreadComputer = ThreadComputer;


/***/ }),

/***/ "./src/ts/threading/thread-plotter.ts":
/*!********************************************!*\
  !*** ./src/ts/threading/thread-plotter.ts ***!
  \********************************************/
/*! flagged exports */
/*! export ThreadPlotter [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ThreadPlotter = void 0;
var parameters_1 = __webpack_require__(/*! ../parameters */ "./src/ts/parameters.ts");
var ThreadPlotter = (function () {
    function ThreadPlotter(plotter, threadComputer) {
        this.plotter = plotter;
        this.threadComputer = threadComputer;
        this.nbSegmentsDrawn = 0;
    }
    ThreadPlotter.prototype.reset = function () {
        this.nbSegmentsDrawn = 0;
    };
    ThreadPlotter.prototype.plot = function () {
        if (this.nbSegmentsDrawn === this.threadComputer.nbSegments) {
            return;
        }
        else if (this.nbSegmentsDrawn > this.threadComputer.nbSegments) {
            this.nbSegmentsDrawn = 0;
        }
        var drawFromScratch = (this.nbSegmentsDrawn === 0);
        if (drawFromScratch) {
            var plotterInfos = {
                backgroundColor: parameters_1.Parameters.invertColors ? "black" : "white",
                blur: parameters_1.Parameters.blur,
            };
            this.plotter.resize();
            this.plotter.initialize(plotterInfos);
            if (parameters_1.Parameters.displayPegs) {
                this.threadComputer.drawPegs(this.plotter);
            }
            this.threadComputer.drawThread(this.plotter, 0);
            this.plotter.finalize();
        }
        else {
            this.threadComputer.drawThread(this.plotter, this.nbSegmentsDrawn);
        }
        this.nbSegmentsDrawn = this.threadComputer.nbSegments;
    };
    return ThreadPlotter;
}());
exports.ThreadPlotter = ThreadPlotter;


/***/ }),

/***/ "./src/ts/threading/thread/thread-base.ts":
/*!************************************************!*\
  !*** ./src/ts/threading/thread/thread-base.ts ***!
  \************************************************/
/*! flagged exports */
/*! export ThreadBase [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ThreadBase = void 0;
var ThreadBase = (function () {
    function ThreadBase() {
        this.sampleCanvas = null;
    }
    ThreadBase.lowerNbSegmentsForThread = function (thread, targetNumber) {
        if (targetNumber > 0) {
            thread.length = Math.min(thread.length, targetNumber + 1);
        }
        else {
            thread.length = 0;
        }
    };
    ThreadBase.computeNbSegments = function (thread) {
        return (thread.length > 1) ? thread.length - 1 : 0;
    };
    ThreadBase.iterateOnThread = function (thread, color, fromSegmentNumber, callback) {
        var threadLength = ThreadBase.computeNbSegments(thread);
        if (fromSegmentNumber < threadLength) {
            var threadPart = thread.slice(fromSegmentNumber);
            callback(threadPart, color);
        }
    };
    return ThreadBase;
}());
exports.ThreadBase = ThreadBase;


/***/ }),

/***/ "./src/ts/threading/thread/thread-monochrome.ts":
/*!******************************************************!*\
  !*** ./src/ts/threading/thread/thread-monochrome.ts ***!
  \******************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 2:17-21 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ThreadMonochrome = void 0;
var compositing_1 = __webpack_require__(/*! ../../plotter/compositing */ "./src/ts/plotter/compositing.ts");
var thread_base_1 = __webpack_require__(/*! ./thread-base */ "./src/ts/threading/thread/thread-base.ts");
var ThreadMonochrome = (function (_super) {
    __extends(ThreadMonochrome, _super);
    function ThreadMonochrome() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.threadPegs = [];
        return _this;
    }
    Object.defineProperty(ThreadMonochrome.prototype, "totalNbSegments", {
        get: function () {
            return thread_base_1.ThreadBase.computeNbSegments(this.threadPegs);
        },
        enumerable: false,
        configurable: true
    });
    ThreadMonochrome.prototype.lowerNbSegments = function (targetNumber) {
        thread_base_1.ThreadBase.lowerNbSegmentsForThread(this.threadPegs, targetNumber);
    };
    ThreadMonochrome.prototype.iterateOnThreads = function (nbSegmentsToIgnore, callback) {
        thread_base_1.ThreadBase.iterateOnThread(this.threadPegs, compositing_1.EColor.MONOCHROME, nbSegmentsToIgnore, callback);
    };
    ThreadMonochrome.prototype.getThreadToGrow = function () {
        return {
            thread: this.threadPegs,
            color: compositing_1.EColor.MONOCHROME,
        };
    };
    ThreadMonochrome.prototype.adjustCanvasData = function (data, blackBackground) {
        var computeAdjustedValue;
        if (blackBackground) {
            computeAdjustedValue = function (rawValue) { return (255 - rawValue) / 2; };
        }
        else {
            computeAdjustedValue = function (rawValue) { return rawValue / 2; };
        }
        var nbPixels = data.length / 4;
        for (var i = 0; i < nbPixels; i++) {
            var averageSourceValue = (data[4 * i + 0] + data[4 * i + 1] + data[4 * i + 2]) / 3;
            var adjustedValue = computeAdjustedValue(averageSourceValue);
            data[4 * i + 0] = adjustedValue;
            data[4 * i + 1] = adjustedValue;
            data[4 * i + 2] = adjustedValue;
        }
    };
    ThreadMonochrome.prototype.enableSamplingFor = function () {
        if (this.sampleCanvas === null) {
            this.sampleCanvas = function (data, index) {
                return data[index + 0];
            };
        }
    };
    return ThreadMonochrome;
}(thread_base_1.ThreadBase));
exports.ThreadMonochrome = ThreadMonochrome;


/***/ }),

/***/ "./src/ts/threading/thread/thread-red-green-blue.ts":
/*!**********************************************************!*\
  !*** ./src/ts/threading/thread/thread-red-green-blue.ts ***!
  \**********************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 2:17-21 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ThreadRedBlueGreen = void 0;
var compositing_1 = __webpack_require__(/*! ../../plotter/compositing */ "./src/ts/plotter/compositing.ts");
var thread_base_1 = __webpack_require__(/*! ./thread-base */ "./src/ts/threading/thread/thread-base.ts");
var ThreadRedBlueGreen = (function (_super) {
    __extends(ThreadRedBlueGreen, _super);
    function ThreadRedBlueGreen() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.threadPegsRed = [];
        _this.threadPegsGreen = [];
        _this.threadPegsBlue = [];
        return _this;
    }
    Object.defineProperty(ThreadRedBlueGreen.prototype, "totalNbSegments", {
        get: function () {
            return thread_base_1.ThreadBase.computeNbSegments(this.threadPegsRed) +
                thread_base_1.ThreadBase.computeNbSegments(this.threadPegsGreen) +
                thread_base_1.ThreadBase.computeNbSegments(this.threadPegsBlue);
        },
        enumerable: false,
        configurable: true
    });
    ThreadRedBlueGreen.prototype.lowerNbSegments = function (targetNumber) {
        var repartition = this.computeIdealSegmentsRepartition(targetNumber);
        thread_base_1.ThreadBase.lowerNbSegmentsForThread(this.threadPegsRed, repartition.red);
        thread_base_1.ThreadBase.lowerNbSegmentsForThread(this.threadPegsGreen, repartition.green);
        thread_base_1.ThreadBase.lowerNbSegmentsForThread(this.threadPegsBlue, repartition.blue);
    };
    ThreadRedBlueGreen.prototype.iterateOnThreads = function (nbSegmentsToIgnore, callback) {
        var repartition = this.computeIdealSegmentsRepartition(nbSegmentsToIgnore);
        thread_base_1.ThreadBase.iterateOnThread(this.threadPegsRed, compositing_1.EColor.RED, repartition.red, callback);
        thread_base_1.ThreadBase.iterateOnThread(this.threadPegsGreen, compositing_1.EColor.GREEN, repartition.green, callback);
        thread_base_1.ThreadBase.iterateOnThread(this.threadPegsBlue, compositing_1.EColor.BLUE, repartition.blue, callback);
    };
    ThreadRedBlueGreen.prototype.getThreadToGrow = function () {
        var repartition = this.computeIdealSegmentsRepartition(this.totalNbSegments + 1);
        if (repartition.red > 0 && this.threadPegsRed.length < repartition.red + 1) {
            return {
                thread: this.threadPegsRed,
                color: compositing_1.EColor.RED,
            };
        }
        else if (repartition.green > 0 && this.threadPegsGreen.length < repartition.green + 1) {
            return {
                thread: this.threadPegsGreen,
                color: compositing_1.EColor.GREEN,
            };
        }
        return {
            thread: this.threadPegsBlue,
            color: compositing_1.EColor.BLUE,
        };
    };
    ThreadRedBlueGreen.prototype.adjustCanvasData = function (data, blackBackground) {
        var cumulatedRed = 0;
        var cumulatedGreen = 0;
        var cumulatedBlue = 0;
        var computeAdjustedValue;
        if (blackBackground) {
            computeAdjustedValue = function (rawValue) { return (255 - rawValue) / 2; };
        }
        else {
            computeAdjustedValue = function (rawValue) { return rawValue / 2; };
        }
        var nbPixels = data.length / 4;
        for (var i = 0; i < nbPixels; i++) {
            cumulatedRed += data[4 * i + 0];
            cumulatedGreen += data[4 * i + 1];
            cumulatedBlue += data[4 * i + 2];
            data[4 * i + 0] = computeAdjustedValue(data[4 * i + 0]);
            data[4 * i + 1] = computeAdjustedValue(data[4 * i + 1]);
            data[4 * i + 2] = computeAdjustedValue(data[4 * i + 2]);
        }
        if (!blackBackground) {
            cumulatedRed = 255 * nbPixels - cumulatedRed;
            cumulatedGreen = 255 * nbPixels - cumulatedGreen;
            cumulatedBlue = 255 * nbPixels - cumulatedBlue;
        }
        var totalColor = cumulatedRed + cumulatedGreen + cumulatedBlue;
        this.frequencyRed = cumulatedRed / totalColor;
        this.frequencyGreen = cumulatedGreen / totalColor;
        this.frequencyBlue = cumulatedBlue / totalColor;
    };
    ThreadRedBlueGreen.prototype.enableSamplingFor = function (color) {
        var channel;
        if (color === compositing_1.EColor.RED) {
            channel = 0;
        }
        else if (color === compositing_1.EColor.GREEN) {
            channel = 1;
        }
        else {
            channel = 2;
        }
        this.sampleCanvas = function (data, index) {
            return data[index + channel];
        };
    };
    ThreadRedBlueGreen.prototype.computeIdealSegmentsRepartition = function (totalNbSegments) {
        var idealRed = totalNbSegments * this.frequencyRed;
        var idealGreen = totalNbSegments * this.frequencyGreen;
        var idealBlue = totalNbSegments * this.frequencyBlue;
        var repartition = {
            red: Math.floor(idealRed),
            green: Math.floor(idealGreen),
            blue: Math.floor(idealBlue),
        };
        while (repartition.red + repartition.green + repartition.blue < totalNbSegments) {
            var currentFrequencyRed = repartition.red / Math.max(1, repartition.red + repartition.green + repartition.blue);
            var currentFrequencyGreen = repartition.green / Math.max(1, repartition.red + repartition.green + repartition.blue);
            var currentFrequencyBlue = repartition.blue / Math.max(1, repartition.red + repartition.green + repartition.blue);
            var gapRed = idealRed - currentFrequencyRed;
            var gapGreen = idealGreen - currentFrequencyGreen;
            var gapBlue = idealBlue - currentFrequencyBlue;
            if (gapRed > gapGreen && gapRed > gapBlue) {
                repartition.red++;
            }
            else if (gapGreen > gapRed && gapGreen > gapBlue) {
                repartition.green++;
            }
            else {
                repartition.blue++;
            }
        }
        return repartition;
    };
    return ThreadRedBlueGreen;
}(thread_base_1.ThreadBase));
exports.ThreadRedBlueGreen = ThreadRedBlueGreen;


/***/ }),

/***/ "./src/ts/threading/transformation.ts":
/*!********************************************!*\
  !*** ./src/ts/threading/transformation.ts ***!
  \********************************************/
/*! flagged exports */
/*! export Transformation [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Transformation = void 0;
var Transformation = (function () {
    function Transformation(frameSize, elementSize) {
        var scaleToFitWidth = frameSize.width / elementSize.width;
        var scaleToFitHeight = frameSize.height / elementSize.height;
        this.scaling = Math.min(scaleToFitWidth, scaleToFitHeight);
        this.origin = {
            x: 0.5 * (frameSize.width - this.scaling * elementSize.width),
            y: 0.5 * (frameSize.height - this.scaling * elementSize.height)
        };
    }
    Transformation.prototype.transform = function (point) {
        return {
            x: this.origin.x + point.x * this.scaling,
            y: this.origin.y + point.y * this.scaling,
        };
    };
    return Transformation;
}());
exports.Transformation = Transformation;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	__webpack_require__("./src/ts/main.ts");
/******/ })()
;
//# sourceMappingURL=main.min.js.map